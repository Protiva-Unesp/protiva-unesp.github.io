{"componentChunkName":"component---src-pages-provas-anteriores-resolucao-markdown-remark-frontmatter-slug-tsx","path":"/provas-anteriores/resolucao/busca-binaria/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Busca Binária","description":"descricao","author":null},"html":"<h2>Problema da busca</h2>\n<p>• Dada uma coleção de n elementos, determinar se um determinado\nelemento (valor) está presente nessa coleção e, se sim, qual a posição\ndesse elemento.\n• Exemplo: busca em vetor de inteiros\nvet = {2, 5, 7, 8, 10}\nbuscar(vet, 7) = 2 //o elemento 7 está na posição 2 do vetor\nbuscar(vet, 2) = 0 //o elemento 2 está na posição 0 do vetor\nbuscar(vet, 3) = -1 //o elemento 3 não se encontra no vetor</p>\n<p>• Generalização: dada uma relação R(x, y), o problema da busca consiste\nem, para um certo valor y, determinar se há um possível valor de x que\nsatisfaça R(x, y), e se sim, retornar este valor.</p>\n<h3>Busca linear</h3>\n<p>• 1ª solução: busca linear ou sequencial – percorrer o vetor desde a\nprimeira posição até a última em busca de um elemento x:\n• Se o elemento for encontrado, retornamos a posição;\n• Senão, retornamos -1 (por exemplo) para indicar que o elemento não\nfoi encontrado.\n• Exemplo de implementação</p>\n<pre><code class=\"language-C++\">int buscaLinear(vector&#x3C;int> vet, int x)\n    {\n    for(int i = 0; i &#x3C; vet.size(); i++)\n    {\n        if (vet[i] == x)\n        return i;\n    }\n    return -1;\n}\n</code></pre>\n<p>• Análise da complexidade: no pior caso, em que o elemento não está no\nvetor, teremos que percorrer todas as n posições do vetor.\n• Sendo assim, esse algoritmo tem complexidade O(n).</p>\n<h3>Busca linear com dados ordenados</h3>\n<p>• Agora suponha que os dados do vetor foram previamente ordenados.\n• Com isso conseguimos melhorar um pouco o algoritmo, pois ao buscar um\nelemento x, se passarmos por um y | y > x, podemos encerrar a busca.\n• Exemplo</p>\n<pre><code class=\"language-C++\">vet = {0, 4, 6, 9, 10, … }\n/*Se buscarmos o número 7 nesse vetor (sabendo que ele está ordenado),\nassim que passarmos pela posição 3 vamos saber que ele não se encontra no\nvetor, mesmo que ele tenha mais 100000 elementos*/\n</code></pre>\n<p>• Exemplo de implementação</p>\n<pre><code class=\"language-C++\">int buscaLinearOrd(vector&#x3C;int> vet, int x)\n{\n    for(int i = 0; i &#x3C; vet.size(); i++)\n    {\n        if (vet[i] == x)\n        return i;\n    if (vet[i] > x)\n        break;\n    }\n    return -1;\n}\n</code></pre>\n<p>• Análise da complexidade: apesar desse algoritmo ser mais “esperto”, se\nsaindo melhor em alguns casos específicos, sua complexidade no pior\ncaso ainda é O(n).\n• Pior caso: o número procurado não está no vetor e é maior que o\núltimo elemento do vetor.</p>\n<h3>Busca binária</h3>\n<p>• Porém, ainda partindo do fato que temos o vetor ordenado, imagine que\nverificamos inicialmente a posição do meio do vetor (e não a primeira\nposição, como na busca linear)\n• O que podemos concluir disso?\ncentro = (inicio + fim) / 2\nSe vet[centro] == x, então o elemento está na posição “centro”\nSe vet[centro] > x, então x só pode estar entre vet[inicio] e vet[centro - 1]\nSe vet[centro] &#x3C; x, então x só pode estar entre vet[centro + 1] e vet[fim]\n• E qual a vantagem disso? Em uma única verificação eliminamos a\nnecessidade de comparar o elemento buscado com metade do vetor.\n• Para a metade onde o elemento x pode estar, aplicamos a mesma ideia,\ncomparando com a posição do meio desse intervalo.</p>\n<p>img1 - img8\n<img src=\"/static/gif1-be4228b2688d264ec633b40d5aeb1b10.gif\" alt=\"gif1\"></p>\n<p>• Exemplo de implementação – versão recursiva:</p>\n<pre><code class=\"language-C++\">int buscaBinaria(int vet[], int esq, int dir, int x)\n{\n    if (esq > dir)\n        return -1;\n    int meio = (esq + dir)/2;\n    if (vet[meio] > x)\n        return buscaBinaria(vet, esq, meio-1, x);\n    if (vet[meio] &#x3C; x)\n        return buscaBinaria(vet, meio+1, dir, x);\n        return meio;\n}\n</code></pre>\n<p>• Exemplo de implementação – versão iterativa:</p>\n<pre><code class=\"language-C++\">int buscaBinaria2(int vet[], int n, int x)\n{\n    int esq = 0, dir = n - 1, meio;\n    while(esq &#x3C;= dir) {\n        meio = (esq + dir)/2;\n        if (vet[meio] == x) return meio;\n        if (vet[meio] > x) dir = meio - 1;\n        else esq = meio + 1;\n    }\n    return -1;\n}\n</code></pre>\n<p>• Análise da complexidade: não iremos fazer a demonstração formal, mas\no fato de dividirmos o intervalo de busca sempre pela metade faz com\nque a complexidade no algoritmo, no pior caso, seja O(log n). Sendo\nassim, mais eficiente que a busca linear.\n• OBS: NÃO ESQUEÇA que o vetor deve estar ordenado, e um algoritmo\nassintoticamente ótimo de ordenação tem complexidade O(n.log n).</p>\n<h3>Busca binária “generalizada”</h3>\n<p>• A busca binária não se aplica somente a busca em vetores, podendo ser\ngeneralizada para diversas aplicações.\n• Em Programação Competitiva, em especial, encontraremos diversos\nproblemas que podem ser resolvidos utilizando busca binária.</p>\n<h3>Fase Regional da Maratona 2019</h3>\n<p>• Problema M: Maratona Brasileira de Comedores de pipocas\nA competição consiste em N sacos de pipocas colocados lado a lado, onde\ncada saco possui uma quantidade arbitrária de pipoca.\nA competição ocorrem em equipes, cada uma composta por C\ncompetidores, e cada competidor pode comer, no máximo, até T pipocas\npor segundos.\nCada competidor da equipe deverá comer uma sequência contígua de\nsacos de pipocas. É perfeitamente válido que um competidor não coma\nnenhuma pipoca.\nTodas as pipocas de um mesmo saco devem ser comidas por um único\ncompetidor.\nO objetivo da competição é comer todas as pipocas no menor tempo\npossível, dado que os C competidores podem comer em paralelo e eles\nrespeitarão todas as regras impostas.\nEntrada\nN = quantidade de sacos de pipocas (&#x3C;= 105)\nC = quantidade de competidores de uma mesma equipe\nT = quantidade máxima de pipoca/s que um competidor pode comer\nPi = quantidade de pipocas no saco i</p>\n<p>• Solução: vamos partir de um problema mais simples:\n• Dado um tempo x, determinar se a equipe é capaz de comer todas as\npipocas neste tempo. Por motivos de simplificação, vamos supor T = 1\n• Para isso, basta percorrer o vetor e tentar atribuir o máximo de sacos\nde pipocas para um competidor (enquanto &#x3C; x). Quando não for\npossível fazer isso, passamos para o próximo competidor.\n• Se conseguirmos chegar no final do vetor, respeitando o limite de\ncompetidores da equipe, então é possível comer as pipocas no tempo\nx.\n• Esse processo tem complexidade O(N)</p>\n<pre><code class=\"language-C++\">bool ehPossivel(vector&#x3C;int> &#x26;pip, int c, int x){\n    int soma = 0, competidorAtual = 0;\n    for(int i = 0; i &#x3C; pip.size(); i++){\n        soma += pip[i];\n    if (soma > x){\n        competidorAtual++;\n        if (competidorAtual == c)\n            return false;\n            soma = pip[i];\n        }\n    }\n    return true;\n}\n</code></pre>\n<p>• Em que isso ajuda? Intuitivamente é possível perceber que até um certo\nvalor k (o tempo mínimo que almejamos) a equipe não conseguirá comer\ntodas as pipocas, e a partir deste tempo ela sempre conseguirá.\n• Se tentássemos representar esse comportamento em um vetor, teríamos\nalgo assim:</p>\n<p>img9.png</p>\n<p>• Esse caráter monotônico, ou monótono, da função permite que\napliquemos uma busca binária para encontrar o tempo k.\n• Quando pensamos nos resultados da função compondo um vetor, é fácil\nver que ela é não decrescente (f(x) &#x3C;= f(x+1)).\n• Em suma, iremos aplicar uma busca binária com esq = 0 e dir = MAX,\nbuscando o primeiro caso em que é possível comer todas as pipocas.\n• Complexidade: O(n.log MAX)</p>\n<pre><code class=\"language-C++\">int solve(vector&#x3C;int> &#x26;pip, int c, int t_ini, int t_fim){\n    int x, k = t_fim;\n    while(t_ini &#x3C;= t_fim){\n        x = (t_ini + t_fim)/2;\n        if (ehPossivel(pip, c, x)){\n        k = x;\n        t_fim = x - 1;\n    } else {\n        t_ini = x + 1;\n        }\n    }\n    return k;\n}\n</code></pre>\n<p>• Como identificar se um problema pode ser resolvido por busca binária?\n• É difícil determinar uma regra geral, além de que depende muito da\nmodelagem e da forma que você está representando o problema.\n• Mas uma dica importante é determinar se o problema possui um caráter\nmonotônico como o exercício anterior.\n• Pode ser descrito por uma função crescente ou decrescente.\nExemplo de problema recorrente: determinar o menor x tal que f(x) >=\nk.\n• Se vale que f(x) &#x3C;= f(x+1) para todo x, então o problema pode ser\nresolvido utilizando busca binária.\n• Exemplo, com k = 20</p>\n<p>img10.png</p>\n<h3>Método da bisseção</h3>\n<p>• Até agora trabalhamos com funções\nno domínio dos inteiros.\n• Esse problema pode ser generalizado\npara funções definida nos reais. Neste\ncaso temos o chamado método da\nbisseção ou bissecção.</p>\n<p>img11.png\n• Exemplo: cálculo de raiz quadrada</p>\n<pre><code class=\"language-C++\">double raiz(double x, double eps=1e-3){\n    double l = 0, r = x;\n    double m;\n    while (r-l > eps){\n        m = (l+r)/2;\n        //cout &#x3C;&#x3C; m &#x3C;&#x3C; endl;\n    if (m*m &#x3C; x)\n        l = m;\n    else\n        r = m;\n    }\n    return (l+r)/2;\n}\n</code></pre>\n<p>• Exemplo: cálculo de raiz quadrada</p>\n<pre><code class=\"language-C++\">sqrt(2) = 1.41421\n    1 1.5 1.25 1.375 1.4375 1.40625 1.42188 1.41406 1.41797\n    1.41602 1.41504 1.41455\nraiz(2) = 1.41455\n</code></pre>\n<h3>Função unimodal</h3>\n<p>• Em alguns problemas também podemos lidar com funções unimodais.\n• Funções que possuem apenas um ponto de mínimo ou máximo.\n• Ou ainda, funções que apresentam apenas dois comportamentos: é\ncrescente em um determinado intervalo e decrescente em outra.\n• Neste caso é mais interessante aplicar uma busca ternária.\nNormalmente estamos procurando justamente o mínimo/máximo da\nfunção.</p>\n<p>Referências\n<a href=\"http://www.ic.unicamp.br/~zanoni/mc102/2013-1s/aulas/aula15.pdf\">http://www.ic.unicamp.br/~zanoni/mc102/2013-1s/aulas/aula15.pdf</a>\n<a href=\"http://www.dcc.fc.up.pt/~pribeiro/aulas/daa1617/slides/2_ordenacao_07102016.pdf\">http://www.dcc.fc.up.pt/~pribeiro/aulas/daa1617/slides/2_ordenacao_07102016.pdf</a>\n<a href=\"https://www.ic.unicamp.br/~ripolito/peds/mc102z/material/aula13.pdf\">https://www.ic.unicamp.br/~ripolito/peds/mc102z/material/aula13.pdf</a>\n<a href=\"https://www.youtube.com/watch?v=GU7DpgHINWQ\">https://www.youtube.com/watch?v=GU7DpgHINWQ</a>\n<a href=\"https://codeforces.com/blog/entry/76686\">https://codeforces.com/blog/entry/76686</a>\n<a href=\"https://sites.google.com/site/calcnum10/home/lista-2/metodos/metodo-da-bisseccao\">https://sites.google.com/site/calcnum10/home/lista-2/metodos/metodo-da-bisseccao</a>\n<a href=\"https://noic.com.br/materiais-informatica/curso/techniques-01/\">https://noic.com.br/materiais-informatica/curso/techniques-01/</a></p>"}},"pageContext":{"id":"c4309ccd-3ff7-54de-b092-d6f1ba09bea4","frontmatter__slug":"busca-binaria","__params":{"frontmatter__slug":"busca-binaria"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}