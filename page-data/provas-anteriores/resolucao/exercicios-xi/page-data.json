{"componentChunkName":"component---src-pages-provas-anteriores-resolucao-markdown-remark-frontmatter-slug-tsx","path":"/provas-anteriores/resolucao/exercicios-xi/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Exercícios XI","description":"descricao","author":null},"html":"<h1>Explicação dos Exercícios de Grafo</h1>\n<h2>Exercícios B, D, E e F</h2>\n<h3>B - Roads of NITT</h3>\n<p>● Existem N hotels conectados entre si por N - 1 arestas.\n● No início, sempre existe um caminho entre dois pares de\nhotéis, mas, com o tempo, algumas rotas se tornam\ninutilizáveis.\n● Dadas Q consultas, determinar quantos pares de hotéis (X,\nY) não tem uma rota entre si.\n● As consultas podem ser de 2 tipos:\n○ R X -> remove a estrada X. É garantido que ela não foi\nremovida anteriormente.\n○ Q -> retorna o resultado do número de pares de hotéis (X, Y)\nque não possuem rota entre si.</p>\n<p>img1 - img23\n<img src=\"/static/gif1-51188587f662e8a7b09fd0e27c3d8c00.gif\" alt=\"gif1\"></p>\n<pre><code class=\"language-C++\">ll q;\ncin >> q;\nvector&#x3C;bool> used(n);\nvi queries(q);\nfor (ll i = 0; i &#x3C; q; i++) {\n    char op;\n    ll id = -1;\n    cin >> op;\n    if (op == 'R') {\n        cin >> id;\n        used[id] = true;\n    }\n    queries[i] = id;\n}\nll conn = 0;\nfor (ll i = 1; i &#x3C; n; i++) {\n    if (!used[i]) {\n        int u, v;\n        tie(u, v) = edges[i];\n        u = find(u);\n        v = find(v);\n        if (u != v) {\n            conn += len[u] * len[v];\n            unite(u, v);\n        }\n    }\n}\nfor (int i = 1; i &#x3C;= n; i++) {\n    find(i);\n}\nll tot = n * (n - 1) / 2 - conn;\nstack&#x3C;ll> ans;\nfor (ll i = q - 1; i >= 0; i--) {\n    ll id = queries[i];\n    if (id != -1) {\n        ll u, v;\n        tie(u, v) = edges[id];\n        u = find(u);\n        v = find(v);\n        if (u != v) {\n            tot -= len[u] * len[v];\n            unite(u, v);\n        }\n    } else {\n    ans.push(tot);\n    }\n}\nwhile (!ans.empty()) {\n    cout &#x3C;&#x3C; ans.top() &#x3C;&#x3C; \"\\n\";\n    ans.pop();\n}\ncout &#x3C;&#x3C; \"\\n\";\n</code></pre>\n<h3>E - Spanning Tree Fraction</h3>\n<p>● Temos um grafo conexo G com N vértices, indexados de 0\naté N - 1, e M arestas.\n● Cada aresta desse grafo é uma quádrupla (U, V, a, b),\nsendo U o vértice de origem, V o vértice de destino, a e\nb pesos da nossa aresta.\n● Achar uma árvore geradora T que contém um subconjunto das\nM arestas e maximize a expressão ∑i∈T ai / ∑i∈T bi, sendo i\no índice da aresta inserida em T.\n● Escrever o termo resultante no formato de uma fração\nirredutível p / q.</p>\n<pre><code class=\"language-C++\">bool cmp(tuple&#x3C;ii, ll, ll> a, tuple&#x3C;ii, ll, ll> b) {\n    ii p, q;\n    p = get&#x3C;0>(a);\n    q = get&#x3C;0>(b);\n    return (p.first - p.second * x) > (q.first - q.second * x);\n}\nint main() {\n    ll n, m;\n    cin >> n >> m;\n    parent = len = vi(n + 1);\n    for (ll i = 0; i &#x3C; m; i++) {\n        ll u, v, a, b;\n        cin >> u >> v >> a >> b;\n        add_edge(u, v, a, b);\n    }\n    ll p, q, gcd;\n    double left = 0., right = 1e7;\n    while (fabs(right - left) >= EPSILON) {\n        x = (left + right) / 2;\n        for (ll i = 0; i &#x3C;= n; i++) {\n            parent[i] = i;\n            len[i] = 1;\n        }\n        p = q = 0;\n        sort(begin(edges), end(edges), cmp);\n        kruskal(p, q);\n        if (p >= q * x) {\n            left = x;\n        } else {\n            right = x;\n        }\n    }\n    gcd = __gcd(p, q);\n    p /= gcd;\n    q /= gcd;\n    cout &#x3C;&#x3C; p &#x3C;&#x3C; \"/\" &#x3C;&#x3C; q &#x3C;&#x3C; \"\\n\";\n    return 0;\n}\n</code></pre>\n<p>F - Airports\n● Você pode colocar aeroportos em qualquer cidade.\n● São dadas as possíveis pistas que ligam as cidades.\n● Objetivo: Garantir que cada cidade tenha acesso a um\naeroporto.</p>\n<p>img24 - img38 (montar gif)\n<img src=\"/static/gif2-6e7c7292323c9fa89d85364257f559d2.gif\" alt=\"gif2\"></p>\n<pre><code class=\"language-C++\">for(int i = 0; i &#x3C; m; i++){\n    cin >> a >> b >> c;\n    arestas.push_back({c, a, b});\n}\nsort(arestas.begin(), arestas.end());\nll custo = 0;\nll ind = lower_bound(arestas.begin(), arestas.end(), make_tuple(aer, 1e17, 1e17))\n- arestas.begin();\nfor(int j = 0; j &#x3C; ind; j++){\n    tie(c, a, b) = arestas[j];\n    if(c == aer)continue;\n    if(find(a) != find(b)){\n        merge(a, b);\n        custo += c;\n    }\n}\n</code></pre>"}},"pageContext":{"id":"7d914a20-3221-5e3b-acac-34fef3426f25","frontmatter__slug":"exercicios-xi","__params":{"frontmatter__slug":"exercicios-xi"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}