{"componentChunkName":"component---src-pages-provas-anteriores-caderno-questoes-markdown-remark-frontmatter-slug-tsx","path":"/provas-anteriores/caderno-questoes/stl-2/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Standard Template Library: Associativos, iteratores e algoritmos","description":"descricao","author":"Rene Pegoraro, Pedro Henrique Paiola, Wilson M Yonezawa"},"html":"<h3>set</h3>\n<p>● Armazenam elementos únicos seguindo uma ordem.\n– um critério de comparação precisa ser definido</p>\n<pre><code class=\"language-C++\">#include &#x3C;string>\n#include &#x3C;set>\nusing namespace std;\nint main() {\n    set &#x3C;string> nome;\n    nome.insert(\"joao\");\n    nome.insert(\"maria\");\n    nome.insert(\"jose\");\n    nome.insert(\"pedro\");\n    nome.insert(\"maria\");\n    nome.insert(\"joao\");\n    printf(\"%d\\n\", nome.size());\n    return 0;\n}\n</code></pre>\n<p>– O set não armazena elementos repetidos\n– No exemplo ao lado, o valor apresentado\nserá 4 (número de elementos no set)\n– Se precisar de armazenar repetições,\nmultiset poderá ser usado\n– Veja também hash_set</p>\n<h3>set - Formas de Ordenação</h3>\n<pre><code class=\"language-C++\">#include &#x3C;string>\n#include &#x3C;set>\nusing namespace std;\nstruct Par {\n    int a, b;\n    Par(int A, int B) : a(A), b(B) {}\n    bool operator&#x3C;(const Par &#x26;p) const {\n        return b &#x3C; p.b;\n    }\n};\n\nstruct comp {\n    bool operator()(const Par &#x26;p1,\n    const Par &#x26;p2) {\n    return p1.a &#x3C; p2.a;\n    }\n}; // Ordem alternativa indicada pelo “operator()”.\n\nint main() {\n    set&#x3C;Par> conj1;\n    conj1.insert(Par(1, 91));\n    conj1.insert(Par(2, 52));\n    conj1.insert(Par(3, 73));\n    conj1.insert(Par(1, 71));\n    set&#x3C;Par, comp> conj2;\n    conj2.insert(Par(1, 91));\n    conj2.insert(Par(2, 52));\n    conj2.insert(Par(3, 73));\n    conj2.insert(Par(1, 71));\n    printf(\"%ld, %ld\\n\",\n    conj1.size(), conj2.size());\n    return 0;\n}\n</code></pre>\n<h3>Exercício Usando set</h3>\n<p>● Resolva o problema URI 2174\n● Recomendações\n– Use set<string> para definir o conjunto de pomekons.\n– Como o conjunto não aceita repetições, basta inserir todos os pokemons\nna lista, mesmo se repetidos, pois eles serão inseridos apenas uma vez.</p>\n<h3>map</h3>\n<p>Mantém pares chave-valor, sendo cada chave única\n– Precisa de um critério de comparação entre as chaves.</p>\n<pre><code class=\"language-C++\">#include &#x3C;cstdio>\n#include &#x3C;map>\n#include &#x3C;string>\nusing namespace std;\nint main () {\n    map&#x3C;string,float> not\n    nota[\"Pedro\"]=10.0;\n    nota[\"Antonio\"]=5.0;\n    nota[\"Maria\"]=7.5;\n    printf(\"%f\\n\", nota[\"Pedro\"]);\n    printf(\"%f\\n\", nota[\"pedro\"]);\n    printf(\"%f\\n\", nota[\"Maria\"]);\n    return 0;\n}\n</code></pre>\n<p>– O dicionário não armazena chaves\nrepetidas\n– O container multimap armazena repetições\n– Usar hash_map e hash_multimap pode\nmelhorar o desempenho mas sem\nordenação</p>\n<h3>Exercício Usando map</h3>\n<p>● Resolva o problema URI 2727\n● Recomendações\n– Use map&#x3C;string,char> para definir a relação chave-valor, assim a chave\nserá o código e o valor o caractere\n– A iniciação do map pode ser feito manualmente, adicionando os 26 códigos\num a um para cada caractere ou programaticamente.\n● Definindo:\n– map&#x3C;string, char> decodifica;\n● Manualmente para a letra “i”, seria:\n– decodifica[\"... ... ...\"] = 'i';\n– Para decodificar, basta ler o código de cada linha em uma string e usá-la\ncomo chave</p>\n<h3>Iteradores (iterator)</h3>\n<p>• Um iterator é qualquer objeto capaz de interagir com os\nelementos de um container usando um conjunto de\noperadores\n• Uma variável iterator funciona como um ponteiro,\n“apontando” para cada elemento do container\n• Um iterator pode ser incrementado, para indicar o\npróximo elemento</p>\n<h3>Iterator Mimetiza Aritmética de Ponteiros</h3>\n<pre><code class=\"language-C++\">#include &#x3C;vector>\n#include &#x3C;cstdio>\nusing namespace std;\nfloat vet[] = {7.8, 1.2, 5.6, 9.0, 3.4};\nvector&#x3C;float> vect(&#x26;vet[0], &#x26;vet[5]);\nint main() {\n    for (vector&#x3C;float>::iterator it = vect.begin();\n        it != vect.end(); it++) {\n        printf(\"%5.1f\", *it);\n    }\n    printf(\"\\n\");\n    for (float *it = &#x26;vet[0]; it != &#x26;vet[5]; it++) {\n        printf(\"%5.1f\", *it);\n    }\nprintf(\"\\n\");\n    for (float f: vect) {\n        printf(\"%5.1f\", f);\n    }\n    printf(\"\\n\");\n    for (float f: vet) {\n        printf(\"%5.1f\", f);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\nfloat f: vect => range-based for\na partir do C++11\n</code></pre>\n<p>No vídeo, obtém-se:\n7.8 1.2 5.6 9.0 3.4\n7.8 1.2 5.6 9.0 3.4\n7.8 1.2 5.6 9.0 3.4\n7.8 1.2 5.6 9.0 3.4</p>\n<h3>Iterator com set</h3>\n<pre><code class=\"language-C++\">#include &#x3C;string>\n#include &#x3C;set>\nusing namespace std;\nint main() {\n    set&#x3C;string> nome;\n    nome.insert(\"joao\");\n    nome.insert(\"maria\");\n    nome.insert(\"jose\");\n    nome.insert(\"pedro\");\n    nome.insert(\"maria\");\n    nome.insert(\"joao\");\n    set&#x3C;string>::iterator iter;\n    for (iter = nome.begin(); iter != nome.end(); iter++) {\n        printf(\"%s\\n\", iter->c_str());\n    }\n    return 0;\n}\n</code></pre>\n<p>No vídeo, obtém-se:\njoao\njose\nmaria\npedro</p>\n<h3>Iterator com set</h3>\n<pre><code class=\"language-C++\">#include &#x3C;string>\n#include &#x3C;set>\nusing namespace std;\nstruct Par {\n    int a, b;\n    Par(int A, int B) {\n    a = A;\n    b = B;\n}\nbool operator&#x3C;(const Par &#x26;p)\nconst {\n    return a &#x3C; p.a;\n    }\n};\n\nint main() {\n    set&#x3C;Par> conj;\n    conj.insert(Par(1, 91));\n    conj.insert(Par(2, 52));\n    conj.insert(Par(3, 73));\n    conj.insert(Par(1, 71));\n    for (set&#x3C;Par>::iterator it =\n    conj.begin();\n    it != conj.end(); it++) {\n        printf(\"%d\\t%d\\n\", it->a, it->b);\n    }\n    return 0;\n}\n</code></pre>\n<p>No vídeo, obtém-se:\n1 91\n2 52\n3 73</p>\n<h3>Iterator com multiset</h3>\n<pre><code class=\"language-C++\">#include &#x3C;string>\n#include &#x3C;set>\nusing namespace std;\nstruct Par {\n    int a, b;\n    Par(int A, int B) :\n    a(A), b(B) {}\n    bool operator&#x3C;(const Par &#x26;p)\n    const {\n        return a &#x3C; p.a;\n    }\n};\n\nint main() {\n    multiset&#x3C;Par> cj;\n    cj.insert(Par(3, 73));\n    cj.insert(Par(1, 91));\n    cj.insert(Par(2, 52));\n    cj.insert(Par(1, 71));\n    multiset&#x3C;Par>::iterator it;\n    for (it = cj.begin();\n    it != cj.end(); it++) {\n        printf(\"%d\\t%d\\n\", it->a, it->b);\n    }\n    return 0;\n}\n</code></pre>\n<p>No vídeo, obtém-se:\n1 91\n1 71\n2 52\n3 73</p>\n<h3>Iterator com map</h3>\n<pre><code class=\"language-C++\">#include &#x3C;cstdio>\n#include &#x3C;map>\n#include &#x3C;string>\nusing namespace std;\nint main () {\n    map&#x3C;string,float> nota;\n    nota[\"Pedro\"]=10.0;\n    nota[\"Antonio\"]=5.0;\n    nota[\"Maria\"]=7.5;\n    map&#x3C;string,float>::iterator iter;\n    for (iter = nota.begin(); iter != nota.end(); iter++) {\n        printf(\"%s,\\t%f\\n\", iter->first.c_str(), iter->second);\n    }\n    return 0;\n}\n</code></pre>\n<p>No vídeo, obtém-se:\nAntonio, 5.000000\nMaria, 7.500000\nPedro, 10.000000</p>\n<h3>Iterator com Variáveis auto C++11</h3>\n<pre><code class=\"language-C++\">#include &#x3C;string>\n#include &#x3C;set>\nusing namespace std;\nint main() {\n    set&#x3C;string> nome;\n    nome.insert(\"joao\"); nome.insert(\"maria\"); nome.insert(\"jose\");\n    nome.insert(\"pedro\"); nome.insert(\"maria\"); nome.insert(\"joao\");\n    for (auto iter = nome.begin(); iter != nome.end(); iter++) {\n        printf(\"%s\\n\", iter->c_str());\n    }\n    for (auto iter: nome) { // iter é uma string, não é iterator.\n        printf(\"%s\\n\", iter.c_str());\n    }\n    return 0;\n}\n</code></pre>\n<h3>Iterator com strings</h3>\n<p>● Os iterators podem ser usados considerando os caracteres\nseparadamente.</p>\n<pre><code class=\"language-C++\">#include &#x3C;iostream>\n#include &#x3C;string>\n#include &#x3C;algorithm>\nint main () {\n    std::string str (\"Test string\");\n    sort(str.begin(), str.end());\n    for (std::string::iterator it = str.begin(); it != str.end(); ++it)\n        std::cout &#x3C;&#x3C; *it;\n    std::cout &#x3C;&#x3C; '\\n';\n    return 0;\n}\n</code></pre>\n<h3>Exercício Usando iterator e list</h3>\n<p>● Resolva o problema onlinejudge 11988\n● Recomendações\n– Use list<char>.\n– Quando um “home” for encontrado, aponte iterator para inserir no início\nda lista; quando for um “end”, aponte o iterator para o fim da fila. Não\nesqueça de atualizar o iterado após cada letra inserida.</p>\n<h3>Exercício Usando iterator</h3>\n<p>● Resolva o problema URI 1244 da forma que deseja, mas\nutilize iterator para apresentar as palavras</p>\n<h3>Algoritmos</h3>\n<p>• Algoritmos que podem ser aplicados aos containers\natravés do iterators\n• Podem modificar ou não os dados\n• Lista em <a href=\"http://www.cplusplus.com/reference/algorithm/\">http://www.cplusplus.com/reference/algorithm/</a></p>\n<h3>stable_sort</h3>\n<pre><code class=\"language-C++\">#include &#x3C;cstdio>\n#include &#x3C;vector>\n#include &#x3C;algorithm>\nusing namespace std;\nstruct Ponto {\n    float x, y;\n    Ponto(float X, float Y) :\n    x(X), y(Y) {};\n};\nvoid mostra(vector&#x3C;Ponto> s) {\n    vector&#x3C;Ponto>::iterator it;\n    printf(\"-----\\n\");\n    for (it = s.begin();\n    it != s.end(); it++)\n    printf(\"%f\\t%f\\n\", it->x, it->y);\n}\nbool operator&#x3C;(const Ponto &#x26;p1,\nconst Ponto &#x26;p2) {\n    return p1.x &#x3C; p2.x;\n}\nint main() {\n    vector&#x3C;Ponto> lPt;\n    lPt.push_back(Ponto(1.2, 2.3));\n    lPt.push_back(Ponto(4.5, 5.6));\n    lPt.push_back(Ponto(1.2, 1.2));\n    lPt.push_back(Ponto(6.7, 7.8));\n    mostra(lPt);\n    stable_sort(lPt.begin(), lPt.end());\n    mostra(lPt);\n    return 0;\n}\n</code></pre>\n<h3>Exercício Usando stable_sort</h3>\n<p>● Resolva o problema URI 1244 usando vector e\nstable_sort\n● Recomendações\n– Use vector<string> para definir a lista.\n– Use a função stable_sort() que ordenar as palavras.</p>\n<h3>replace_if</h3>\n<pre><code class=\"language-C++\">#include &#x3C;iostream>\n#include &#x3C;algorithm>\nusing namespace std;\nbool ehMaior(int i) { return i > 10; }\nint main() {\n    int vet[] = { 10, 90, 4, -10, 25, 93, 10, 7, 0, 33 };\n    for (int i=0; i&#x3C;10; i++)\n        printf(\"%3d \", vet[i]);\n    printf(\"\\n\");\n    replace_if(vet, vet+10, ehMaior, 10);\n    for (int i=0; i&#x3C;10; i++)\n        printf(\"%3d \", vet[i]);\n    return 0;\n}\n</code></pre>\n<p>No vídeo, obtém-se:\n10 90 4 -10 25 93 10 7 0 33\n10 10 4 -10 10 10 10 7 0 10</p>\n<h3>replace_if</h3>\n<pre><code class=\"language-C++\">#include &#x3C;deque>\n#include &#x3C;algorithm>\n#include &#x3C;string>\nusing namespace std;\nbool iniciaComJ(string s) {\n    return s[0] == 'J';\n}\nint main() {\n    deque&#x3C;string> vet;\n    vet.push_back(\"Joao\");\n    vet.push_back(\"Maria\");\n    vet.push_back(\"Pedro\");\n    vet.push_back(\"Jose\");\n    vet.push_back(\"Antonio\");\n    for (auto i = vet.begin();\n        i!=vet.end(); i++)\n    printf(\"%s \", i->c_str());\n    printf(\"\\n\");\n    replace_if(vet.begin(), vet.end(),\n    iniciaComJ, \"XXXX\");\n    for (auto i = vet.begin();\n    i!=vet.end(); i++)\n        printf(\"%s \", i->c_str());\n    return 0;\n}\n</code></pre>\n<p>No vídeo, obtém-se:\nJoao Maria Pedro Jose Antonio\nXXXX Maria Pedro XXXX Antonio</p>\n<h3>Algoritmos e Iteradores</h3>\n<p>● Os algoritmos set_difference, set_union, set_intersection, entre\noutros, realizam operações sobre containers.\n● Estas funções recebem iteradores de entrada e saída\n● Insert_iterators são iteradores de saída desenvolvidos para\npermitir que algoritmos que normalmente escrevam elementos\npossam ser usados para inserir elementos em containers.\nset_difference(conj1Entra.begin(), conj1Entra.end(),\nconj2Entra.begin(), conj2Entra.end(),\ninserter(conjSaida, conjSaida.begin()));\n● Veja também: back_inserter, front_inserter e insert_iterator\n● Tipos diferentes de destinos podem ser usados, desde que o insert\niterator utilize a rotina de inserção correspondente ao container destino</p>\n<pre><code class=\"language-C++\">#include &#x3C;algorithm>\n#include &#x3C;list>\n#include &#x3C;string>\n#include &#x3C;vector>\nusing namespace std;\nint main() {\n    vector&#x3C;string> vet1;\n    vet1.push_back(\"banana\");\n    vet1.push_back(\"pera\");\n    vet1.push_back(\"maça\");\n    string vet2[] = {\"abacaxi\", \"laranja\", \"pera\"};\n    list&#x3C;string> l;\n    set_difference(vet1.begin(), vet1.end(),\n    vet2, vet2 + 3,\n    front_inserter(l));\n. . .\n\n</code></pre>\n<h3>Functores</h3>\n<p>Rotinas que retornam instâncias de classes que\nimplementam o operador () usado em comparações nos\nalgoritmos\n● A escolha de um functor indica o que ocorrerá no\nalgoritmo escolhido\n● Na omissão de um functor, o less é normalmente\nusado</p>\n<h3>Functores - greater</h3>\n<pre><code class=\"language-C++\">#include &#x3C;vector>\n#include &#x3C;algorithm>\n#include &#x3C;string>\nusing namespace std;\nint main() {\n    vector&#x3C;string> vet;\n    vet.push_back(\"Joao\");\n    vet.push_back(\"Maria\");\n    vet.push_back(\"Pedro\");\n    vet.push_back(\"Jose\");\n    vet.push_back(\"Antonio\");\n    sort(vet.begin(), vet.end(),\n    greater&#x3C;string>());\n    for (auto i = vet.begin();\n        i!=vet.end(); i++)\n    printf(\"%s \", i->c_str());\n    printf(\"\\n\");\n    return 0;\n}\n\n</code></pre>\n<p>No vídeo, obtém-se:\nJoao Maria Pedro Jose Antonio\nXXXX Maria Pedro XXXX Antonio</p>\n<h3>Containers de containers</h3>\n<p>● Em containers de containers é necessário inserir os\ncontainers mais internos um a um.\n● Por exemplo:\n– vector&#x3C;set<int> > adj\n– Cria um vetor de conjuntos, mas cada conjunto deve ser inserido\nexplicitamente nos elementos do vector para que possam ser usados</p>"}},"pageContext":{"id":"01f7bdb0-60bf-5e88-9026-de1c08142a62","frontmatter__slug":"stl-2","__params":{"frontmatter__slug":"stl-2"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}