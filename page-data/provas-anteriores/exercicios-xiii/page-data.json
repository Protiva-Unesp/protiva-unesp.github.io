{"componentChunkName":"component---src-pages-provas-anteriores-markdown-remark-frontmatter-slug-tsx","path":"/provas-anteriores/exercicios-xiii/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"02 - Exercícios","description":"descricao","author":null},"html":"<h2>Resolução Exercícios Teoria dos Números</h2>\n<h3>Exercício B, E e F</h3>\n<h3>B - T-Primes</h3>\n<ul>\n<li>T-Primes são números positivos que tem exatamente 3 divisores distintos.</li>\n<li>Dado n inteiros, determine quando os mesmo são ou não T-primes.</li>\n<li>Entrada:</li>\n</ul>\n<pre><code>n (1 ≤ n ≤ 10^5 )\nxi (1 ≤ xi ≤ 10^12 )\n</code></pre>\n<ul>\n<li>Como encontrar os T-Primes? Pela definição, conseguimos assumir que um número x é um T-prime, se seus divisores forem apenas: 1, (algum_numero_primo), x Por exemplo, um número primo, não é um T-prime, pois ele é divisível apenas por ele mesmo e 1.</li>\n<li>Mas qual número primo se encaixa nessa configuração?</li>\n</ul>\n<pre><code>1 &#x3C; (algum_numero_primo) &#x3C; x\n</code></pre>\n<ul>\n<li>O único número que se encaixa nessa configuração seria um número primo multiplicado por ele mesmo que gerasse x, exemplo:</li>\n</ul>\n<pre><code>Para x = 9,\n1 &#x3C; 3 &#x3C; 9\n</code></pre>\n<ul>\n<li>Solução: Dado um número n:</li>\n</ul>\n<pre><code class=\"language-C++\">if (n == 1) cout &#x3C;&#x3C; “NO”;\nelse if (quadrado_perfeito(n) &#x26;&#x26; ehPrimo[sqrt(n)])\n    cout &#x3C;&#x3C; “YES”;\nelse\n    cout &#x3C;&#x3C; “NO”;\n</code></pre>\n<ul>\n<li>Para x = 16, 16 é um quadrado perfeito, mas como sqrt(16) = 4 e 4 não é um número primo, ficamos no final com mais de 3 divisores: 1,2,4,8,16</li>\n</ul>\n<pre><code class=\"language-C++\">vector&#x3C;bool> ehPrimo;\nll MAXN = 1000000;\nvoid crivo()\n{\n    ehPrimo = vector&#x3C;bool>(MAXN + 1, true);\n    ehPrimo[0] = ehPrimo[1] = false;\n    for (ll i = 2; i * i &#x3C;= MAXN; i++)\n    {\n        if (!ehPrimo[i])continue;\n        for (ll m = i * i; m &#x3C;= MAXN; m += i)\n        ehPrimo[m] = false;\n    }\n}\n</code></pre>\n<h3>E - RSA Attack</h3>\n<ul>\n<li>\n<p>O enunciado nos apresenta o seguinte problema</p>\n<ul>\n<li>Achar um inteiro m que satisfaça a equação: m^e (mod n) = c (mod n)</li>\n<li>Onde:</li>\n<li>n é o produto de dois números primos ímpares, p e q</li>\n<li>gcd(e, (p - 1)(q - 1)) = 1</li>\n<li>e &#x3C; (p - 1)(q - 1)</li>\n<li>e, n, c &#x3C;= 32000</li>\n</ul>\n</li>\n<li>\n<p>1ª ETAPA: manipular a equação</p>\n<ul>\n<li>Precisamos encontrar o valor de m, mas, no estado atual de nossa equação, temos apenas o valor de me, logo, queremos eliminar essa potência.</li>\n</ul>\n</li>\n</ul>\n<p>me (mod n) = c (mod n)</p>\n<p>elevar ambos os lados da equação por x</p>\n<p>(me)x (mod n) = (c)x (mod n)</p>\n<p>mex (mod n) = cx (mod n)</p>\n<ul>\n<li>\n<p>Podemos, então, supor que ex = 1, pois, assim, mex = m1.</p>\n</li>\n<li>\n<p>Assim, temos: m (mod n) = cx (mod n)</p>\n</li>\n<li>\n<p>Agora, sabemos que o valor de m é o resultado da potência cx.</p>\n</li>\n<li>\n<p>Contudo, não sabemos o valor de x, portanto precisamos encontrá-lo.</p>\n</li>\n<li>\n<p>2ª ETAPA: encontrar o valor de x</p>\n<ul>\n<li>Para tal, vamos utilizar as seguintes afirmações do exercício:\n<ol>\n<li>ex = 1</li>\n<li>gcd(e, (p - 1)(q - 1)) = 1</li>\n<li>e &#x3C; (p - 1)(q - 1)</li>\n<li></li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>Podemos perceber, pelas afirmações 1 e 2, que:</p>\n</li>\n</ul>\n<p>ex = gcd(e, (p - 1)(q - 1)) = 1</p>\n<ul>\n<li>Uma equação diofantina tem o formato:</li>\n</ul>\n<p>ax + by = c</p>\n<ul>\n<li>E sabemos que podemos resolver através do algoritmo estendido de</li>\n</ul>\n<p>Euclides equações diofantinas com a seguinte configuração;</p>\n<p>ax + by = gcd(a, b) = c</p>\n<ul>\n<li>Comparando nossa equação atual com a equação diofantina geral:</li>\n</ul>\n<p>ex = gcd(e, (p - 1)(q - 1)) = 1 (I)</p>\n<p>ax + by = gcd(a, b) = c (II)</p>\n<ul>\n<li>Percebemos que:</li>\n</ul>\n<p>a = e</p>\n<p>b = (p - 1)(q - 1)</p>\n<p>c = 1</p>\n<ul>\n<li>Portanto, podemos escrever nossa equação como:</li>\n</ul>\n<p>ex + (p - 1)(q - 1)y = gcd(e, (p - 1)(q - 1)) = 1</p>\n<ul>\n<li>\n<p>E descobrimos os valores de x e de y aplicando o algoritmo estendido de Euclides.</p>\n</li>\n<li>\n<p>O exercício nos garante que encontraremos uma solução para o problema, então não precisamos nos preocupar com isso.</p>\n</li>\n<li>\n<p>3ª Etapa: definir os valores para p e q</p>\n<ul>\n<li>Os valores de p e q não estão definidos para aplicarmos na equação que obtemos, porém sabemos que n = p * q.</li>\n<li>Assim, testamos valores de p e q da seguinte maneira:</li>\n</ul>\n<ol>\n<li>Dado um número p, verificamos se p é primo.</li>\n<li>Se p é primo, verificamos se a divisão n / p é inteira por meio da expressão n % p == 0.</li>\n<li>Se a divisão for inteira, verificamos se o valor q = n / p também é primo.</li>\n<li>Se todos os itens anteriores forem verdadeiros, encontramos p e q.</li>\n</ol>\n</li>\n<li>\n<p>Cuidados:</p>\n</li>\n<li>\n<p>x pode ser um valor negativo na resolução da equação diofantina, pois se uma solução é possível, elas admitem infinitas soluções.</p>\n</li>\n<li>\n<p>Porém, temos que:</p>\n</li>\n</ul>\n<p>e &#x3C; (p - 1)(q - 1) (I)</p>\n<p>ex = 1 -> e = 1 / x (II)</p>\n<ul>\n<li>Para garantir I, podemos reescrever II como:</li>\n</ul>\n<p>e (mod (p - 1)(q - 1)) * x = 1</p>\n<ul>\n<li>Aplicando propriedades da álgebra modular, obtemos:</li>\n</ul>\n<p>ex (mod (p - 1)(q - 1)) = 1 (mod (p - 1)(q - 1))</p>\n<ul>\n<li>Assim, e levando em consideração que x é a multiplicativa inversa de e, podemos concluir que:</li>\n</ul>\n<p>e, x &#x3C; (p - 1)(q - 1) = mod</p>\n<p>Se x &#x3C; 0, x = (x % mod + mod) % mod</p>\n<p>Senão, x = x % mod</p>\n<pre><code class=\"language-C++\">vector&#x3C;bool> is_prime;\nvector&#x3C;int> primes;\nvoid crivo(const int &#x26;n) {\n    is_prime = vector&#x3C;bool>(n + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i * i &#x3C;= n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j &#x3C;= n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    for (int i = 2; i &#x3C;= n; i++) {\n        if (is_prime[i])\n            primes.push_back(i);\n    }\n}\n\ncrivo(32000);\nwhile (k--) {\n    int e, n, c, p, q;\n    cin >> e >> n >> c;\n    for (int i = 0; i &#x3C; m; i++) {\n        p = primes[i];\n        if (n % p == 0 &#x26;&#x26; is_prime[n / p]) {\n            q = n / p;\n            break;\n        }\n    }\n    int x, y, mod = (p - 1) * (q - 1);\n    extended_gcd(e, mod, x, y);\n    x = (x % mod + mod) % mod;\n    cout &#x3C;&#x3C; pow_mod(c, x, n) &#x3C;&#x3C; \"\\n\";\n}\n\nll pow_mod(ll b, ll x, ll mod) {\n    ll m = 1LL;\n    while (x) {\n        if (x &#x26; 1) {\n            m = (m * b) % mod;\n        }\n        b = (b * b) % mod;\n        x >>= 1;\n    }\n    return m;\n}\n</code></pre>\n<h3>F - DDF</h3>\n<ul>\n<li>\n<p>É dado o início e o fim de um intervalo</p>\n</li>\n<li>\n<p>O objetivo é saber qual o número com a maior sequência DDF nesse intervalo.</p>\n</li>\n<li>\n<p>DDF -> Decimal Digit Factor Sequence</p>\n</li>\n<li>\n<p>Confira na GIF abaixo:</p>\n</li>\n</ul>\n<p><img src=\"/static/gif1-dd79a2ce8655280e88abdb2b2008a5ff.gif\" alt=\"img1-img4\"></p>\n<ul>\n<li>Objetivo: Encontrar a maior DDF no intervalo dado.</li>\n<li>Como o intervalo vai de 1 a 3000 no máximo e o tamanho de uma DDF é no máximo 1000, pode-se calcular todas as DDFs, de maneira offline, e pegar a maior.</li>\n</ul>\n<pre><code class=\"language-C++\">ll soma_digitos(ll num){\n    ll sum = 0;\n    while(num){\n        sum += num%10;\n        num/=10;\n    }\n        return sum;\n}\nll fatorar(ll n){\n    vector&#x3C;ll> fator;\n    ll soma = 0;\n    for (ll i = 1; i * i &#x3C;= n; i++){\n        if(n%i == 0){\n            if(n != i*i)soma += soma_digitos(n/i);\n            soma += soma_digitos(i);\n        }\n    }\n    return soma;\n}\nvector&#x3C;ll> ddf [3001];\nfor(int i = 1; i &#x3C;= 3000; i++){\n    ll ant = i, res = i;\n    ddf[i].push_back(i);\n    while(1){\n        res = fatorar(res);\n        if(ant == res)break;\n        ddf[i].push_back(res);\n        ant = res;\n    }\n}\n</code></pre>"}},"pageContext":{"id":"8d0c9837-5705-538d-b416-b8a7a181d95a","frontmatter__slug":"exercicios-xiii","__params":{"frontmatter__slug":"exercicios-xiii"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}