{"componentChunkName":"component---src-pages-introducao-a-programacao-ordenacao-markdown-remark-frontmatter-slug-tsx","path":"/introducao-a-programacao/ordenacao/grafos-2/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Introdução à Teoria dos Grafos - Parte II","description":"descricao","author":"Pedro Henrique Paiola, Rene Pegoraro, Wilson M Yonezawa"},"html":"<h3>Problema do Caminho Mínimo</h3>\n<p>• Imagine o seguinte problema: dado um mapa de cidades, contendo o\ncomprimento das estradas entre as cidades, qual o menor caminho entre\nquaisquer cidades A e B?\n• Esse problema pode ser modelado através de um grafo:\n• Cidades: vértices;\n• Estradas entre cidades: arestas ponderadas com peso que indicam a distância entre as cidades.\n• Generalizando, o nosso problema é encontrar o caminho de menor custo\nem um grafo de um vértice A até um vértice B.\n• Chamamos de custo de um caminho a soma dos pesos das arestas\npertencentes a esse caminho.</p>\n<p>• Existem alguns algoritmos clássicos que resolvem tal problema:\n• Dijkstra\n• Para pesos não negativos\n• Complexidade: 𝑂( 𝑉 + 𝐴 log 𝑉)\n• Bellman-Ford\n• Permite lidar com pesos negativos\n• Complexidade: 𝑂(𝑉. 𝐴)\n• Floyd-Warshall\n• Permite lidar com pesos negativos\n• Encontra o menor caminho entre todo os pares de vértices (𝑢, 𝑣)\n• Complexidade: 𝑂(𝑉3)</p>\n<h3>Algoritmo de Dijkstra</h3>\n<p>• Este algoritmo parte de uma estimativa inicial para o custo mínimo e vai,\niterativamente, ajustando esta estimativa.\n• A busca se inicia a partir de um vértice, a qual denominamos origem.\n• Ele considera que um vértice estará fechado quando já tiver sido obtido\num caminho de custo mínimo da origem até ele. Caso contrário, ele é\ndito aberto.</p>\n<p>• Pseudocódigo: seja 𝐺(𝑉, 𝐴) um grafo e 𝑠 um vértice de 𝐺 (origem):</p>\n<pre><code>1. Atribua valor zero à estimativa de custo mínimo do vértice 𝑠 e ∞ às demais.\n2. Enquanto houver vértice aberto:\n\tA. Seja 𝑘 um vértice ainda aberto cuja estimativa seja a menor entre todos os\nvértices abertos: fechar o vértice 𝑘\n\tB. Para todo o vértice 𝑗 ainda aberto que seja adjacente à 𝑘 faça:\n\t\ti. Soma a estimativa do vértice 𝑘 com o custo da aresta 𝑘, 𝑗\n\t\tii. Caso essa estimativa seja melhor que a anterior para 𝑗, substitua e anote 𝑘 como precedente (“pai”) de 𝑗\n</code></pre>\n<p>img1 - img12\n<img src=\"/static/gif1-256500bfa98cecf9e764d8a95cfe0daf.gif\" alt=\"gif1\"></p>\n<pre><code class=\"language-C++\">int d[MAX_V]; //d[i] armazena a distância até o vértice i, e as\n//estimativas durante as iterações\nint p[MAX_V]; //armazena o predecessor de cada vértice\nvoid dijkstra(int inicial, int vertices){\n    priority_queue&#x3C; pair&#x3C;int, int> > heap; //distância, vértice\n    int s, t, peso;\n    for(int i = 0; i &#x3C; vertices; i++)\n    d[i] = INT_MAX;\n    memset(p, -1, sizeof(p));\n    heap.push(make_pair(d[inicial] = 0, inicial));\n    while(!heap.empty()){\n        s = heap.top().second;\n        heap.pop();\n        for(int i = 0; i &#x3C; grau[s]; i++){\n            t = adj[s][i].v;\n            peso = adj[s][i].w;\n            if (d[s] + peso &#x3C; d[t]){\n            d[t] = d[s] + peso;\n            p[t] = s;\n            heap.push(make_pair(-d[t], t));\n            }\n        }\n    }\n}\n</code></pre>\n<p>Analisando a complexidade desse algoritmo de forma intuitiva, temos\nque (pensando no pior caso):\n• Todos os vértices são fechados: |𝑉| operações\n• Cada vez que um vértice é fechado, é porque ele foi extraído de uma heap: custo\n𝑂 1 ⇒ 𝑂(|𝑉|)\n• Para cada vértice, todas as suas arestas são acessadas. No total, acessaremos |𝐴| arestas ⇒ 𝑂(|𝑉| + |𝐴|)\n• Cada vez que uma aresta é acessada, podemos inserir um elemento na heap: custo 𝑂(log |𝑉|) ⇒ 𝑂((|𝑉| + |𝐴|) ∗ log |𝑉|)\n• Complexidade: 𝑂( (|𝑉| + |𝐴|) . log |𝑉|)</p>\n<h3>Caminho mínimo com arcos negativos</h3>\n<p>• O algoritmo de Dijkstra se baseia em uma estratégia gulosa, e esta falha\nquando temos arestas com pesos negativos.\n• Quando fechamos o vértice aberto com menor distância até ele,\nestamos supondo que nenhum outro caminho até ele é menor.\n• Quando os pesos são não negativos, isso é verdade porque qualquer\noutro caminho irá utilizar arestas com peso maior ou igual a zero.\n• Porém, se existem arcos negativos, podemos ter caminhos que no\nmomento apresentam um custo maior, mas posteriormente terão este\ncusto reduzido pela adição de um arco negativo.</p>\n<p>img13 - img15\n<img src=\"/static/gif2-c1ecd8576de171d313352c88cd8ae5f9.gif\" alt=\"gif2\"></p>\n<p>• Quando pode aparecer arcos negativos em problemas de caminho\nmínimo?\n• Parece não fazer muito sentido falar em “distância” com arcos negativos, mas\npodemos ter diversos tipos de outros problemas em que esta situação se apresente.\n• Por exemplo: problemas envolvendo dinheiro, onde arcos positivos representam\ngastos e arcos negativos representam lucro. Nesse caso, um caminho mínimo\nmaximiza o lucro.\n• Situação análoga: jogo em que os vértices representam estados, arcos positivos\nsão transições que diminuem a pontuação do jogador, e arcos negativos são\ntransições que aumentam a pontuação.\n• Caso insolúvel: presença de ciclos negativos\n• “Dar uma volta” em um ciclo de custo negativo sempre diminui o\ncusto final.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/0d1ae84db0d347bad7e27f07105481b8/cec12/img16.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 39.263803680981596%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA5ElEQVR42p1Ra2/DIAzk///FTmsnJYra8YaQB4SbTdp9yLRF2kmWsbGPMxY4RcUyejLXzmcQf13OywIlJYKR8PoT1miUsp0QViqo+8uVfH16xjAMuFzesG2l1XR9j/v98RR+UMsxcYmcAubokFLCx+0GpTTWKSJahUB2RIoeo1NYU4QxBu/XK0IImLyhXICYgwUbJ621MGSjp9goajTfal+Iju60bITe+9bDfqKeTDmxS60H9XuslULXdSh5bTU9j/w4Gfm3zTLymuGsoYVIJFLLS8m5/H/LL3L+U/4fYPsh7Ej4BV/Mc9J/oVHMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img16' title='' src='/static/0d1ae84db0d347bad7e27f07105481b8/a6d36/img16.png' srcset='/static/0d1ae84db0d347bad7e27f07105481b8/222b7/img16.png 163w,\n/static/0d1ae84db0d347bad7e27f07105481b8/ff46a/img16.png 325w,\n/static/0d1ae84db0d347bad7e27f07105481b8/a6d36/img16.png 650w,\n/static/0d1ae84db0d347bad7e27f07105481b8/e548f/img16.png 975w,\n/static/0d1ae84db0d347bad7e27f07105481b8/cec12/img16.png 1187w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h3>Algoritmo de Bellman-Ford</h3>\n<p>• Para encontrar um caminho mínimo em um grafo com a presença de\narcos negativos, podemos utilizar o algoritmo de Bellman-Ford.\n• Se houver ciclos negativos, ele irá detectar.\n• O algoritmo de Bellman-Ford é dividido em três etapas:\n• Inicialização: padronização das distâncias\n• Relaxamento: cálculo efetivo dos caminhos mínimos\n• Verificação de ciclos negativos\n• Inicialização: como no Dijkstra, a distância até a origem é inicializada\ncom 0 e as outras como infinito.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/e68f17c090a69db53f606e3684017629/2bef9/img17.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.44171779141104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtElEQVR42p1Sy0pcQRC9X5nvEL8iECNZBbJwkRCzzECMo7gJmF2icSFERdFMmKuO87z9un1vP45V3UPwMUSw4FBdp7tOV1V30el0cHF+DrbWtfDewYdA3sNz7Dj2yTteM38XxEXKPerfYO/wNwoWCmII1zuAH5wSzhBGPfirE/jyCIF8uCFuWtL6GHF2jWwRdy3GmC4ochQQrQJ8i0gAVRS5qsYgtBZWS1hj4CzH9QOp+1YsIjUlCyGgqylENYNUGkprGK1gZIWqqlKMBdLzCvOGn5SY7W3A1Da1wKJ1XSfftm06M5mMU2uGLtViSh25RRVmwaDG0Gc/UkWcxJVEeiBHaxZlEUneOQ8pJRqj07iebLm2DYkqWCVguUKpUsztc8uKLjTW/meG3DKDqok0dJp8QuBHIfg5QlMTbf7tR0ejcU2GzyMpuNn652eIj0sQn5ahvr4irGR030CT191V6M3XCcylM5ur+QxzX17CfP9AovNvY3fXIN++gFpfQiz/IPYJgxLusod43ac/+TeB14+4AXGUE0b5fxbjX9sY7a5juPMOw2/vMdnfega2MT3YwXi/i1vYHkCH9c1mOwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img17' title='' src='/static/e68f17c090a69db53f606e3684017629/a6d36/img17.png' srcset='/static/e68f17c090a69db53f606e3684017629/222b7/img17.png 163w,\n/static/e68f17c090a69db53f606e3684017629/ff46a/img17.png 325w,\n/static/e68f17c090a69db53f606e3684017629/a6d36/img17.png 650w,\n/static/e68f17c090a69db53f606e3684017629/e548f/img17.png 975w,\n/static/e68f17c090a69db53f606e3684017629/2bef9/img17.png 1024w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>• Relaxamento: a técnica do relaxamento consiste em verificar se pode\nser encontrado um caminho mais curto para 𝑣 passando por um certo\nvértice 𝑢:\nse d[u] + peso(u, v) &#x3C; d[v] então\nd[v] = d[u] + peso(u,v)\np[v] = u\n• De forma semelhante ao Dijkstra, isso será feito 𝑉 − 1 vezes, porém\nconsiderando TODAS as arestas, e não apenas as incidentes no último\nvértice “fechado”.</p>\n<p>img18 - img35\n<img src=\"/static/gif3-ae7c7830013c5f44dd1174a821b8fc6f.gif\" alt=\"gif3\"></p>\n<p>• Checagem de ciclos negativos: o relaxamento é aplicado mais uma vez.\n• Se houver alguma situação em que se encontre caminho melhor, é por\nque temos a presença de um ciclo negativo.\n• Caso em que sempre pode-se encontrar um caminho menor, ao “andar” mais uma\nvez pelo ciclo.</p>\n<pre><code>BellmanFord(G, origem)\n    d[v] = infinito, para todo v\n    p[v] = -1, para todo v\n    d[origem] = 0\n    para i de 1 até |V(G)| - 1 faça\n        para cada aresta (u,v) de G faça\n            relax(u, v, w)\n    para cada aresta (u,v) de G faça\n        se d[v] > d[u] + peso(u,v)\n            retorna FALSE\n    retorna TRUE\n</code></pre>\n<pre><code class=\"language-C++\">bool bellmanFord(int inicial, int n){\n    memset(p, -1, sizeof(p));\n    for(int i=0; i&#x3C;n; i++)\n        d[i] = INF;\n    d[inicial] = 0;\n    for(int i = 0; i &#x3C; n-1; i++){ //|V|-1 passos\n        for(int j = 0; j &#x3C; n; j++){ //para todas as\n            if (d[j] == INF)\n                continue;\n            for(int k = 0; k &#x3C; grau[j]; k++){ //arestas (j, k)\n                if(d[j] + adj[j][k].w &#x3C; d[adj[j][k].v])\n                {\n                    d[adj[j][k].v] = d[j] + adj[j][k].w;\n                    p[adj[j][k].v] = j;\n                }\n            }\n        }\n    }\n    //Verificando se há ciclo negativo\n    for(int i=0; i&#x3C;n; i++){\n        if (d[i] == INF)\n            continue;\n        for(int j = 0; j &#x3C; grau[i]; j++){\n            if (d[adj[i][j].v] > d[i] + adj[i][j].w)\n                return false;\n        }\n    }\n    return true;\n}\n</code></pre>\n<h3>Caminho Euleriano</h3>\n<p>• Um caminho euleriano é um caminho que percorre cada aresta de um\ngrafo exatamente uma vez.\n• Um circuito ou ciclo euleriano é um caminho euleriano que começa e\ntermina no mesmo vértice.\n• As sete pontes de Königsberg</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/9546e9c4e31ae1ba6f387fe9ede80978/0098c/img36.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 49.69325153374233%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACPklEQVR42l2SS08aYRSG+V3ttqvGVVddNenWTVP3NWlqjE2a1MRUJq2maQjepThcRC6DUxWQW6OSAqYahQgiFwUGQQWefiPS0J7kzMxi3uf7znlfQ7fbpd+aplGv12mIt1arUSmXKZZKVCoVLi4uuLy8pNPpQLvda1G6brAM+qPZbJJMJlEUBZ/Px04wyFYkgsfrJRqNoqoqLpeLdYcDTfx/N22kMjLCPfIB/EDvAY+OjrDb7TiFwL7hxjEzS+rRYzYWl9gKBJBlGZvNhtftpnp9DYUCobk5kicn1BoN2nd3/94wlUrdC2xrMvPLC1iX5th++waPX8EvWpatWG12LNY1GjpQ1JVYzb6YoHR4SCaXo1os0hYHGBr1GsfpFD8UDw6HD2llhm/eBeYtYyxLRiYVE0bFzNR6hCmnSrneEKN17sctDA+jjY9zJva6L26sDQ1h8O2lmLV5MIse+27ls+UrC9urOF+9JvrsOR/jk7gsEtknT8nGYvSHKwrD9sSea5Uy+fNzatUq3esmBu+v4/uTP8kqkmrny66ZD6vvmXYqvNs8wBROk9lPUHLItArnPVoiQVySODw9pSpA7QFjDM16lYNICN+mj7DRSO7FSzb9W6SiQeyx30hhN8tBiaV0EVMiy5UQdcwmtImJnst6jPrx0V3W6bF4HH8gSHhlhfToKOrONpFYlFDoJ+u7i6jZAMHcDWdaqydmMCn/5VAPqh7mknApJzorvrOZDPl8nptWi/bt7aD8b974D9QH/gEtzL5S4E9XLgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img36' title='' src='/static/9546e9c4e31ae1ba6f387fe9ede80978/a6d36/img36.png' srcset='/static/9546e9c4e31ae1ba6f387fe9ede80978/222b7/img36.png 163w,\n/static/9546e9c4e31ae1ba6f387fe9ede80978/ff46a/img36.png 325w,\n/static/9546e9c4e31ae1ba6f387fe9ede80978/a6d36/img36.png 650w,\n/static/9546e9c4e31ae1ba6f387fe9ede80978/0098c/img36.png 775w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>• Ao resolver o problema das sete pontes de Königsberg, Euler descobriu\nque existem critérios simples para determinar se um multigrafo tem um\ncaminho ou ciclo euleriano:\n• Um multigrafo conexo com, pelo menos, dois vértices tem um ciclo euleriano se, e\nsomente se, cada um de seus vértices tiver grau par.\n• Um multigrafo conexo tem um caminho euleriano (que não seja um ciclo) se, e somente se, tiver exatamente dois vértices de grau ímpar.\n• Aplicações em problemas práticos:\n• Problema do carteiro chinês: encontrar um caminho de menor custo que visite cada aresta do grafo ao menos uma vez.\n• Desenho de circuitos.\n• Redes de computadores de distribuição múltipla de dados.\n• Sequenciamento de DNA.\n• Problemas:\n• CodeForces 508D - Tanya and Password\n• URI 1671 - Código\n• URI 1053 - Desenho Contínuo</p>\n<h3>Caminho Hamiltoniano</h3>\n<p>• Um caminho hamiltoniano de um grafo 𝐺 é um caminho que passa por\ntodos os vértices de 𝐺 exatamente uma vez.\n• Um ciclo hamiltoniano é um caminho hamiltoniano que começa e\ntermina no mesmo vértice.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 314px; '>\n      <a class='gatsby-resp-image-link' href='/static/73f5e998454ac151c4b961f2fe1c59e0/5b158/img37.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 95.70552147239263%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAACrklEQVR42o1UAXeaQAz2//+rvW1t7aoVEBAQaKuICqgIKCDy7RIE7d7qds949xLyXZIvl97hcICmaVBVFb7vg1Zd1/jXar+ZzWadfxzH6JmmiSiK2CgrMhzHwWq1YvDlcvlJSE/7YrHgnb6VpBH7pkkKXdfRMwwDSZKwkm56n7mIggjr9RpBECAMw26ni+nMtnWIuT+DLCnsSxgMmKR7qCMdhmxj+s1HFbY53cu3+asCwP2+hPHqQJMM7BORMpmy1QmhmotPaoSPNY4ecCwPiHcx+1dVxUJ12213bDvOgfDpzMAb5YTMq/jMgEVUI7UvV4vf24+Io3ZcB67jdoG5rgvbtaFLJuYPO+Dc+CSmCGDRpNQAbkQN7GueylhGnucNUbIMIo6k3++zrigKaLraXZRYwGGOrwEn+gRBGKA8FQzYkjIYDFCWhTgHMA2zKyhll338FbBZeXEUaVlQHgwEUdDpw00A5afBtkN+uAKKqmTvXwDWl7rkAmevN2fq4VYfj8E21p8bn0wApu6dCAuRqqW40J8cbONNp9/uN9AfHVhjF3mZdxFSdKl9p4bUoKv1CoVwGksajkGFPDxjNJRZtxY2IqkDFPVLp3cAFUVBkRcNQdIUoVRiI58w6isXlkt+VW2DEyAx3QHmog8T6yxMTVGGwyEzOp1OWdpl2zYL2UlawPSD/Oubxg6vN+iaDs/zOMLtdtsR1RJAOupRaiVFVlChQPomXpBWNRFScS3VxfR1hsHoFzzx4D+PsPrPR9zZ9mmMofwC7cWC1hel2azRoxR8fyGYzTF4HiD1jsiXovO9muW4wCfJLvrMO+Ms2kcdaNjtd/zWaSb2JpMJsizjGy3NxuIlQWY2Pcii3citThd1E7v+bKOsim789agmdKBIbwn434lNs5HajNqIpvdvgfamQx+U/lMAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img37' title='' src='/static/73f5e998454ac151c4b961f2fe1c59e0/5b158/img37.png' srcset='/static/73f5e998454ac151c4b961f2fe1c59e0/222b7/img37.png 163w,\n/static/73f5e998454ac151c4b961f2fe1c59e0/5b158/img37.png 314w' sizes='(max-width: 314px) 100vw, 314px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>• A solução desse problema é mais complexa do que o problema do\ncaminho euleriano. Já foram encontradas algumas condições suficientes\npara dizer se um grafo possui um caminho hamiltoniano, mas nenhuma\ncondição necessária e suficiente.\n• O melhor algoritmo conhecido para encontrar um ciclo hamiltoniano (ou\ndeterminar se existe) tem complexidade exponencial.\n• Problema do Caixeiro Viajante: encontrar a menor rota que um caixeiro-\nviajante deveria tomar para visitar um conjunto de cidades.\n• Esse problema se reduz a encontrar um ciclo hamiltoniano em um grafo\ncom o menor custo possível (custo = soma dos pesos das arestas do\ncaminho).</p>\n<h3>Referências</h3>\n<p>Aulas de Estrutura de Dados II da Profª Drª Marcia Aparecida Zanoli Meira e Silva.\nMatemática Discreta e Suas Aplicações. Kenneth H. Rosen.\nSeminário sobre Introdução a Teoria dos Grafos. Davi Neves, Giovani Candido, Luis Morelli\ne Luiz Sementille.\nBiblioteca de códigos de Thiago Alexandre Domingues de Souza.\n<a href=\"https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/graphs.html\">https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/graphs.html</a>\n<a href=\"http://www.inf.ufsc.br/grafos/definicoes/definicao.html\">http://www.inf.ufsc.br/grafos/definicoes/definicao.html</a>\n<a href=\"https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/shortestpaths.html\">https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/shortestpaths.html</a>\n<a href=\"https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/cheapestpaths.html\">https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/cheapestpaths.html</a>\n<a href=\"http://professor.ufabc.edu.br/~leticia.bueno/classes/aa/materiais/caminhominimo.pdf\">http://professor.ufabc.edu.br/~leticia.bueno/classes/aa/materiais/caminhominimo.pdf</a>\n<a href=\"http://www.inf.ufsc.br/grafos/temas/custo-minimo/dijkstra.html\">http://www.inf.ufsc.br/grafos/temas/custo-minimo/dijkstra.html</a>\n<a href=\"https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/dijkstra.html\">https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/dijkstra.html</a>\n<a href=\"http://www.deinf.ufma.br/~portela/ed211_Dijkstra.pdf\">http://www.deinf.ufma.br/~portela/ed211_Dijkstra.pdf</a>\n<a href=\"http://www.facom.ufu.br/~madriana/ED2/6-AlgDijkstra.pdf\">http://www.facom.ufu.br/~madriana/ED2/6-AlgDijkstra.pdf</a>\n<a href=\"https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/bellman-ford.html\">https://www.ime.usp.br/~pf/algoritmos_para_grafos/aulas/bellman-ford.html</a>\n<a href=\"https://www.ic.unicamp.br/~rezende/ensino/mo417/2010s2/Slides/Aula23.pdf\">https://www.ic.unicamp.br/~rezende/ensino/mo417/2010s2/Slides/Aula23.pdf</a>\n<a href=\"http://www.dt.fee.unicamp.br/~ricfow/IA881/caminhoMinimo.pdf\">http://www.dt.fee.unicamp.br/~ricfow/IA881/caminhoMinimo.pdf</a>\n<a href=\"https://pt.slideshare.net/jackocap/anlise-de-algoritmos-problemas-em-grafos-caminho-mnimo-algoritmo-de-bellmanford\">https://pt.slideshare.net/jackocap/anlise-de-algoritmos-problemas-em-grafos-caminho-mnimo-algoritmo-de-bellmanford</a></p>"}},"pageContext":{"id":"90914ed0-e2a9-581d-85fd-0d02daea37b7","frontmatter__slug":"grafos-2","__params":{"frontmatter__slug":"grafos-2"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}