{"componentChunkName":"component---src-pages-introducao-a-programacao-ordenacao-markdown-remark-frontmatter-slug-tsx","path":"/introducao-a-programacao/ordenacao/stl/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"01 - Standard Template Library","description":"descricao","author":"Rene Pegoraro, Pedro Henrique Paiola, Wilson M Yonezawa"},"html":"<h2>Sequenciais e Adaptadores</h2>\n<h3>Introdução</h3>\n<ul>\n<li>O STL é uma biblioteca frequentemente incluída nos compiladores C++.</li>\n<li>Ela fornece elementos do tipo containers, iteradores, algoritmos e functores (funções objetos)</li>\n<li>Eles podem ser usados com praticamente qualquer tipo de dado</li>\n</ul>\n<h3>Containers</h3>\n<h4>Sequenciais</h4>\n<ul>\n<li>vector</li>\n<li>list</li>\n<li>deque</li>\n</ul>\n<h4>Adaptadores</h4>\n<ul>\n<li>queue</li>\n<li>stack</li>\n<li>priority_queue</li>\n</ul>\n<h3>Associativos</h3>\n<ul>\n<li>set, multiset,</li>\n<li>map e multimap</li>\n<li>hash_set, hash_multiset</li>\n<li>hash_map e hash_multimap</li>\n</ul>\n<h3>Como escolher um container?</h3>\n<ul>\n<li>A escolha de um container depende das características específicas desejadas</li>\n<li>operações disponíveis</li>\n<li>complexidade de cada operação</li>\n<li>Tabela comparativa em <a href=\"http://www.cplusplus.com/reference/stl/\">http://www.cplusplus.com/reference/stl/</a></li>\n</ul>\n<h3>Containers</h3>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/4de732f3832f2b5344eb784799f0e958/d43b4/img1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 46.62576687116564%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAACVElEQVR42iWSW1PSURTF/1Nq9tBjHyBTs0/hJS8BQgpe8DbTU1aKNvXSR9GiRuSiCAiImk5a36BMonrJycmMkovIRfgD/trQw5q1Z52195yzzlYuTYe5+jRMjSVMbQWzYa49i3D9+RdqHu9Rb/lE/cwHaqf3qZuNUPckwuWpsPBn8Ub+91j2uWLZE/0jii5QomPxhF5hw1oZjS+PIVik15dF78uhcydptx6i82a440rSKdAHCrQ7YnQtpaQuovWKbzlBl+03yvRumQeBGJadErPvYeZdWXDB9Fu1Wlu2z5lcS/BoI8WE40DwnYehJOPClXpmt4hFMLWVZTJ0itLouKDRekqT84JmZ5mGRZVbws12lSZ7keaFHDfmTmhZPOfmfIymFzFu2/M0zP2l+WVcfAUabAVabDkaX6VQxjaLDDiPGNtQGQudY3L9kjrPiP8M82qKYc8JBus3xuV8wP2HQW+C+ztgtB/KWYzRYFp6jpnYKmGWfkUfLNPt+CP5ldB60nTajtH78/SuZtGspNBINh0LR9Vc7y7FRTujfxO67VG07lPx5uhxxbm3XkYXUFH6gwV65r9iDOQx+TMYXFH6ZJhhRcJ3J+jzJNG+PsAUkk9zx+nzphmQgXrHMUZPAuNqml5nFNOail4upAyFVIzLUYbXi4y+KWPeVBmV55kDGczBrGhFBoMZxrcRj+jiq9RDobx4y1XvUCDLiPCgsNJqj9Nq/UGbM4FOnq/xq1X0rKTpXj5F65N1WfiJXiLpqKyNO41BbthWWRtPDq2sTZdo1bgcJ/wDzckAQNk3gkQAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img1' title='' src='/static/4de732f3832f2b5344eb784799f0e958/a6d36/img1.png' srcset='/static/4de732f3832f2b5344eb784799f0e958/222b7/img1.png 163w,\n/static/4de732f3832f2b5344eb784799f0e958/ff46a/img1.png 325w,\n/static/4de732f3832f2b5344eb784799f0e958/a6d36/img1.png 650w,\n/static/4de732f3832f2b5344eb784799f0e958/e548f/img1.png 975w,\n/static/4de732f3832f2b5344eb784799f0e958/d43b4/img1.png 1202w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>C = amortized constant time\n<a href=\"http://www.tantalon.com/pete/cppopt/appendix.htm\">http://www.tantalon.com/pete/cppopt/appendix.htm</a></p>\n<h3>vector</h3>\n<ul>\n<li>Sequência contígua de dados com tamanho variável.</li>\n</ul>\n<pre><code class=\"language-C++\">#include &#x3C;cstdio>\n#include &#x3C;vector>\nusing namespace std;\nint main() {\n    vector&#x3C;float> vf;\n    vf.push_back(1.23);\n    vf.push_back(9.87);\n    vf.push_back(6.45);\n    printf(\"%f, %f, %f, %f, %d\\n\", vf[0], vf[1], vf[2], vf[10], vf.size());\n    printf(\"%f\\n\", vf.back());\n    vf.pop_back();\n    printf(\"%f, %f, %f, %d\\n\", vf[0], vf[1], vf[2], vf.size());\n    return 0;\n}\n</code></pre>\n<p>Obtém-se:</p>\n<pre><code>1.230000, 9.870000, 6.450000, 0.000000 (lixo), 3\n6.450000\n1.230000, 9.870000, 6.450000 (lixo), 2\n</code></pre>\n<h3>list</h3>\n<ul>\n<li>Lista sequencial de dados com tamanho variável.</li>\n</ul>\n<pre><code class=\"language-C++\">#include &#x3C;cstdio>\n#include &#x3C;list>\nusing namespace std;\n    struct Ponto {\n    float x, y;\n    Ponto(float X, float Y) {\n        x = X;\n        y = Y;\n    }\n};\n\n// Obs: o operador [ ] não pode ser usado em list\n\nint main() {\n    list&#x3C;Ponto> lPt;\n    Ponto p(1.2, 2.3);\n    lPt.push_back(p);\n    lPt.push_front(Ponto(4.5, 5.6));\n    lPt.push_back(Ponto(6.7, 7.8));\n    int n = lPt.size();\n    for (int i = 0; i &#x3C; n; i++) {\n        printf(\"(%f, %f)\\n\", lPt.front().x, lPt.front().y);\n        lPt.pop_front();\n    }\n    return 0;\n}\n</code></pre>\n<p>Obtém-se:</p>\n<pre><code>(4.500000, 5.600000)\n(1.200000, 2.300000)\n(6.700000, 7.800000)\n</code></pre>\n<h3>Ordenação (estável) em list</h3>\n<ul>\n<li>list pode se ordenar usando a função membro sort()</li>\n</ul>\n<pre><code class=\"language-C++\">#include &#x3C;cstdio>\n#include &#x3C;list>\nusing namespace std;\nstruct Ponto {\n    float x, y;\n    Ponto(float X, float Y) {\n        x = X;\n        y = Y;\n    }\n};\n    bool ordem(Ponto &#x26;p1, Ponto &#x26;p2) {\n    return p1.x &#x3C; p2.x;\n}\n\nint main() {\n    list&#x3C;Ponto> lPt;\n    lPt.push_back(Ponto(1.2, 2.3));\n    lPt.push_front(Ponto(4.5, 5.6));\n    lPt.push_back(Ponto(6.7, 7.8));\n    lPt.sort(ordem);\n    int n = lPt.size();\n    for (int i = 0; i &#x3C; n; i++) {\n        printf(\"(%f, %f)\\n\", lPt.front().x, lPt.front().y);\n        lPt.pop_front();\n    }\n    return 0;\n}\n</code></pre>\n<p>Obtém-se:</p>\n<pre><code>(1.200000, 2.300000)\n(4.500000, 5.600000)\n(6.700000, 7.800000)\n</code></pre>\n<ul>\n<li>list pode se ordenar usando a ordem natural</li>\n</ul>\n<pre><code class=\"language-C++\">#include &#x3C;cstdio>\n#include &#x3C;list>\nusing namespace std;\nstruct Ponto {\n    float x, y;\n    Ponto(float X, float Y) {\n        x = X;\n        y = Y;\n    }\n    bool operator&#x3C;(Ponto &#x26;p) {\n        return x &#x3C; p.x;\n    }\n};\n\n// O “operator&#x3C;” determina a ordem natural dos Ponto’s\n\nint main() {\n    list&#x3C;Ponto> lPt;\n    lPt.push_back(Ponto(1.2, 2.3));\n    lPt.push_front(Ponto(4.5, 5.6));\n    lPt.push_back(Ponto(6.7, 7.8));\n    lPt.sort();\n    int n = lPt.size();\n    for (int i = 0; i &#x3C; n; i++) {\n        printf(\"(%f, %f)\\n\", lPt.front().x,\n        lPt.front().y);\n        lPt.pop_front();\n    }\n    return 0;\n}\n</code></pre>\n<p>Obtém-se:</p>\n<pre><code>(1.200000, 2.300000)\n(4.500000, 5.600000)\n(6.700000, 7.800000)\n</code></pre>\n<h3>Exercício usando list</h3>\n<ul>\n<li>Resolva o problema URI 1244</li>\n<li>Recomendações\n<ul>\n<li>Use <code>list&#x3C;string></code> para definir a lista.</li>\n<li>Use a função membro sort() da list pois, após a ordenação, o problema precisa que os elementos de mesmo comprimento permaneçam na ordem original, ou seja, a ordenação deve ser estável.</li>\n</ul>\n</li>\n</ul>\n<h3>Outras operações em list</h3>\n<ul>\n<li>Funções membros\n<ul>\n<li><code>splice</code> Move elementos de uma lista para outra</li>\n<li><code>remove</code> Remove elementos com valor específico</li>\n<li><code>remove_if</code> Remove elementos com condição</li>\n<li><code>merge</code> Junta listas ordenadas</li>\n<li><code>sort</code> Ordena elementos no container</li>\n<li><code>reverse</code> Inverte a ordem dos elementos</li>\n</ul>\n</li>\n</ul>\n<h3>Deque - Double-Ended QUEue</h3>\n<ul>\n<li>Semelhante à vector\n<ul>\n<li>permite inserir e remover do início e fim da sequência</li>\n<li>operador <code>[]</code></li>\n<li>sem as operações de list</li>\n</ul>\n</li>\n</ul>\n<h3>Stack - Last In First Out - Pilha</h3>\n<ul>\n<li>Funções membros\n<ul>\n<li><code>empty</code> testa se o container está vazio</li>\n<li><code>size</code> retorna o tamanho</li>\n<li><code>top</code> faz acesso ao próximo elemento</li>\n<li><code>push</code> adiciona um elemento ao topo</li>\n<li><code>pop</code> remove o elemento do topo</li>\n</ul>\n</li>\n</ul>\n<h3>Exercício usando pilha</h3>\n<ul>\n<li>Resolva o problema Plug-in do Codeforces\n<ul>\n<li><a href=\"https://codeforces.com/contest/81/problem/A\">https://codeforces.com/contest/81/problem/A</a></li>\n</ul>\n</li>\n<li>Recomendações\n<ul>\n<li>Use stack<char> para definir uma pilha.</li>\n<li>Quando o último caractere lido for igual ao do topo da pilha, o caractere deve ser ignorado e também retirado do topo da pilha.</li>\n</ul>\n</li>\n</ul>\n<h3>Queue (Fila) - First In First Out</h3>\n<ul>\n<li>Funções membros\n<ul>\n<li><code>empty</code> Testa se o container está vazio</li>\n<li><code>size</code> Retorna o tamanho</li>\n<li><code>front</code> Faz acesso ao primeiro elemento</li>\n<li><code>back</code> Faz acesso ao último elemento</li>\n<li><code>push</code> Insere um elemento no final da fila</li>\n<li>``pop` Apaga o primeiro elemento da fila</li>\n</ul>\n</li>\n</ul>\n<h3>Uso de queue</h3>\n<pre><code class=\"language-C++\">#include &#x3C;cstdio>\n#include &#x3C;queue>\n#include &#x3C;cstring>\nusing namespace std;\nstruct Pessoa {\n    char nome[30];\n    float salario;\n    Pessoa(char nome[],\n    float sal) {\n    strcpy(this->nome, nome);\n    salario = sal;\n    }\n};\n\nint main () {\n    queue&#x3C;Pessoa> fila;\n    fila.push(Pessoa(\"Rene\", 10.00));\n    fila.push(Pessoa(\"Maria\", 80.00));\n    fila.push(Pessoa(\"Jose\", 50.00));\n    while (!fila.empty()) {\n        printf(\"%s \", fila.front().nome);\n        fila.pop();\n    }\n    return 0;\n}\n\nint main () {\n    queue&#x3C;Pessoa> fila;\n    fila.push(Pessoa(\"Rene\", 10.00));\n    fila.push(Pessoa(\"Maria\", 80.00));\n    fila.push(Pessoa(\"Jose\", 50.00));\n    while (!fila.empty()) {\n        printf(\"%s \", fila.front().nome);\n        fila.pop();\n    }\n    return 0;\n}\n</code></pre>\n<h3>priority_queue – Fila com Prioridade</h3>\n<ul>\n<li>Fila com critério de prioridade\n<ul>\n<li>se o critério for igual, vale a ordem de entrada</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-C++\">#include &#x3C;cstdio>\n#include &#x3C;queue>\n#include &#x3C;string>\nusing namespace std;\nstruct Pessoa {\n    string nome; float sal;\n    Pessoa(string nome, float sal) {\n        this->nome = nome;\n        this->sal = sal;\n    }\n    bool operator&#x3C;(Pessoa &#x26;p) {\n        return sal &#x3C; p.sal;\n    }\n};\n\nint main () {\n    priority_queue&#x3C;Pessoa> fila;\n    fila.push(Pessoa(\"Pedro\", 10.00));\n    fila.push(Pessoa(\"Maria\", 80.00));\n    fila.push(Pessoa(\"Jose\", 50.00));\n    while (!fila.empty()) {\n        printf(\"%s \", fila.top().nome.c_str());\n        fila.pop();\n    }\n    return 0;\n}\n</code></pre>\n<p>Obtém-se:</p>\n<pre><code>Maria Jose Pedro\n</code></pre>\n<h3>Exercício usando priority_queue</h3>\n<ul>\n<li>Resolva o problema URI 1244 agora usando priority_queue</li>\n<li>Recomendações\n<ul>\n<li>Use <code>priority_queue&#x3C;string></code> para definir a lista.</li>\n<li>Coloque como critério de prioridade o número de caracteres da palavra, quando terminar de inserir todas as palavras a ordem já estará como exigida no problema.</li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"id":"686bcbdd-732b-5c7c-a44a-c81241d2f3c3","frontmatter__slug":"stl","__params":{"frontmatter__slug":"stl"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}