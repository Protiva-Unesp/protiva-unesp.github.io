{"componentChunkName":"component---src-pages-introducao-a-programacao-ordenacao-markdown-remark-frontmatter-slug-tsx","path":"/introducao-a-programacao/ordenacao/exercicios-xiii/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Exercícios XIII","description":"descricao","author":null},"html":"<h1>Resolução Exercícios Teoria dos Números</h1>\n<h2>Exercício B, E e F</h2>\n<h3>B - T-Primes</h3>\n<p>● T-Primes são números positivos que tem exatamente 3\ndivisores distintos.\n● Dado n inteiros, determine quando os mesmo são ou não\nT-primes.\nEntrada:</p>\n<p>n (1 ≤ n ≤ 10^5 )\nxi (1 ≤ xi ≤ 10^12 )</p>\n<p>● Como encontrar os T-Primes ?\nPela definição, conseguimos assumir que um número x é um\nT-prime, se seus divisores forem apenas:\n1, (algum_numero_primo), x\nPor exemplo, um número primo, não é um T-prime, pois ele\né divisível apenas por ele mesmo e 1.</p>\n<p>● Mas qual número primo se encaixa nessa configuração?\n1 &#x3C; (algum_numero_primo) &#x3C; x\nO único número que se encaixa nessa configuração seria um\nnúmero primo multiplicado por ele mesmo que gerasse x,\nexemplo:\nPara x = 9,\n1 &#x3C; 3 &#x3C; 9</p>\n<p>● Solução: Dado um número n:</p>\n<pre><code class=\"language-C++\">if (n == 1) cout &#x3C;&#x3C; “NO”;\nelse if (quadrado_perfeito(n) &#x26;&#x26; ehPrimo[sqrt(n)])\n    cout &#x3C;&#x3C; “YES”;\nelse\n    cout &#x3C;&#x3C; “NO”;\n</code></pre>\n<p>Para x = 16,\n16 é um quadrado perfeito, mas como sqrt(16) = 4 e 4 não\né um número primo, ficamos no final com mais de 3 divisores:\n1,2,4,8,16</p>\n<pre><code class=\"language-C++\">vector&#x3C;bool> ehPrimo;\nll MAXN = 1000000;\nvoid crivo()\n{\n    ehPrimo = vector&#x3C;bool>(MAXN + 1, true);\n    ehPrimo[0] = ehPrimo[1] = false;\n    for (ll i = 2; i * i &#x3C;= MAXN; i++)\n    {\n        if (!ehPrimo[i])continue;\n        for (ll m = i * i; m &#x3C;= MAXN; m += i)\n        ehPrimo[m] = false;\n    }\n}\n</code></pre>\n<h3>E - RSA Attack</h3>\n<p>● O enunciado nos apresenta o seguinte problema\n○ Achar um inteiro m que satisfaça a equação:\nm^e (mod n) = c (mod n)\n○ Onde:\n○ n é o produto de dois números primos ímpares, p e q\n○ gcd(e, (p - 1)(q - 1)) = 1\n○ e &#x3C; (p - 1)(q - 1)\n○ e, n, c &#x3C;= 32000</p>\n<p>● 1ª ETAPA: manipular a equação\n○ Precisamos encontrar o valor de m, mas, no estado atual de nossa\nequação, temos apenas o valor de me, logo, queremos eliminar essa potência.</p>\n<p>me (mod n) = c (mod n)\nelevar ambos os lados da equação por x\n(me)x (mod n) = (c)x (mod n)\nmex (mod n) = cx (mod n)</p>\n<p>○ Podemos, então, supor que ex = 1, pois, assim, mex = m1.\n○ Assim, temos:\nm (mod n) = cx (mod n)\n○ Agora, sabemos que o valor de m é o resultado da potência cx.\n○ Contudo, não sabemos o valor de x, portanto precisamos encontrá-lo.</p>\n<p>● 2ª ETAPA: encontrar o valor de x\n○ Para tal, vamos utilizar as seguintes afirmações do exercício:</p>\n<ol>\n<li>ex = 1</li>\n<li>gcd(e, (p - 1)(q - 1)) = 1</li>\n<li>e &#x3C; (p - 1)(q - 1)</li>\n<li></li>\n</ol>\n<p>○ Podemos perceber, pelas afirmações 1 e 2, que:\nex = gcd(e, (p - 1)(q - 1)) = 1</p>\n<p>○ Uma equação diofantina tem o formato:\nax + by = c\n○ E sabemos que podemos resolver através do algoritmo estendido de\nEuclides equações diofantinas com a seguinte configuração;\nax + by = gcd(a, b) = c</p>\n<p>○ Comparando nossa equação atual com a equação diofantina geral:\nex = gcd(e, (p - 1)(q - 1)) = 1 (I)\nax + by = gcd(a, b) = c (II)\n○ Percebemos que:\n■ a = e\n■ b = (p - 1)(q - 1)\n■ c = 1</p>\n<p>○ Portanto, podemos escrever nossa equação como:\nex + (p - 1)(q - 1)y = gcd(e, (p - 1)(q - 1)) = 1\n○ E descobrimos os valores de x e de y aplicando o algoritmo estendido\nde Euclides.\n○ O exercício nos garante que encontraremos uma solução para o\nproblema, então não precisamos nos preocupar com isso.</p>\n<p>● 3ª Etapa: definir os valores para p e q\n○ Os valores de p e q não estão definidos para aplicarmos na equação\nque obtemos, porém sabemos que n = p * q.\n○ Assim, testamos valores de p e q da seguinte maneira:</p>\n<ol>\n<li>Dado um número p, verificamos se p é primo.</li>\n<li>Se p é primo, verificamos se a divisão n / p é inteira por meio</li>\n</ol>\n<p>da expressão n % p == 0.\n3. Se a divisão for inteira, verificamos se o valor q = n / p também\né primo.\n4. Se todos os itens anteriores forem verdadeiros, encontramos p e\nq.</p>\n<p>● Cuidados:\n○ x pode ser um valor negativo na resolução da equação diofantina, pois\nse uma solução é possível, elas admitem infinitas soluções.\n○ Porém, temos que:\ne &#x3C; (p - 1)(q - 1) (I)\nex = 1 -> e = 1 / x (II)\n○ Para garantir I, podemos reescrever II como:\ne (mod (p - 1)(q - 1)) * x = 1</p>\n<p>○ Aplicando propriedades da álgebra modular, obtemos:\nex (mod (p - 1)(q - 1)) = 1 (mod (p - 1)(q - 1))\n○ Assim, e levando em consideração que x é a multiplicativa inversa de\ne, podemos concluir que:\ne, x &#x3C; (p - 1)(q - 1) = mod\nSe x &#x3C; 0, x = (x % mod + mod) % mod\nSenão, x = x % mod</p>\n<pre><code class=\"language-C++\">vector&#x3C;bool> is_prime;\nvector&#x3C;int> primes;\nvoid crivo(const int &#x26;n) {\n    is_prime = vector&#x3C;bool>(n + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i * i &#x3C;= n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j &#x3C;= n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    for (int i = 2; i &#x3C;= n; i++) {\n        if (is_prime[i])\n            primes.push_back(i);\n    }\n}\n\ncrivo(32000);\nwhile (k--) {\n    int e, n, c, p, q;\n    cin >> e >> n >> c;\n    for (int i = 0; i &#x3C; m; i++) {\n        p = primes[i];\n        if (n % p == 0 &#x26;&#x26; is_prime[n / p]) {\n            q = n / p;\n            break;\n        }\n    }\n    int x, y, mod = (p - 1) * (q - 1);\n    extended_gcd(e, mod, x, y);\n    x = (x % mod + mod) % mod;\n    cout &#x3C;&#x3C; pow_mod(c, x, n) &#x3C;&#x3C; \"\\n\";\n}\n\nll pow_mod(ll b, ll x, ll mod) {\n    ll m = 1LL;\n    while (x) {\n        if (x &#x26; 1) {\n            m = (m * b) % mod;\n        }\n        b = (b * b) % mod;\n        x >>= 1;\n    }\n    return m;\n}\n</code></pre>\n<h3>F - DDF</h3>\n<p>● É dado o início e o fim de um intervalo\n● O objetivo é saber qual o número com a maior sequência\nDDF nesse intervalo.\n● DDF -> Decimal Digit Factor Sequence</p>\n<p>img1 - img4\n<img src=\"/static/gif1-dd79a2ce8655280e88abdb2b2008a5ff.gif\" alt=\"gif1\"></p>\n<p>Objetivo: Encontrar a maior DDF no intervalo dado.\n● Como o intervalo vai de 1 a 3000 no máximo e o tamanho de\numa DDF é no máximo 1000, pode-se calcular todas as DDFs,\nde maneira offline, e pegar a maior.</p>\n<pre><code class=\"language-C++\">ll soma_digitos(ll num){\n    ll sum = 0;\n    while(num){\n        sum += num%10;\n        num/=10;\n    }\n        return sum;\n}\nll fatorar(ll n){\n    vector&#x3C;ll> fator;\n    ll soma = 0;\n    for (ll i = 1; i * i &#x3C;= n; i++){\n        if(n%i == 0){\n            if(n != i*i)soma += soma_digitos(n/i);\n            soma += soma_digitos(i);\n        }\n    }\n    return soma;\n}\nvector&#x3C;ll> ddf [3001];\nfor(int i = 1; i &#x3C;= 3000; i++){\n    ll ant = i, res = i;\n    ddf[i].push_back(i);\n    while(1){\n        res = fatorar(res);\n        if(ant == res)break;\n        ddf[i].push_back(res);\n        ant = res;\n    }\n}\n</code></pre>"}},"pageContext":{"id":"449d2daa-e22c-5002-b3ce-1d38a0b52354","frontmatter__slug":"exercicios-xiii","__params":{"frontmatter__slug":"exercicios-xiii"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}