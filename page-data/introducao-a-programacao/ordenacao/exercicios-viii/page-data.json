{"componentChunkName":"component---src-pages-introducao-a-programacao-ordenacao-markdown-remark-frontmatter-slug-tsx","path":"/introducao-a-programacao/ordenacao/exercicios-viii/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Exercícios VIII","description":"descricao","author":null},"html":"<h2>Resolução dos Exercícios</h2>\n<h2>Exercícios A, D, F, E</h2>\n<h3>A - Cthulhu</h3>\n<p>Vamos supor que um Cthulhu consiga ser representado no espaço como sendo:\n● Um grafo não direcionado que pode ser representado como um conjunto de uma árvore ou mais árvores que estão conectadas por um círculo simples Na entrada é garantido que não existem múltiplas arestas nem self-loops</p>\n<p>Solução:</p>\n<pre><code class=\"language-C++\">if (conexo == true &#x26;&#x26; num_arestas == num_vertices)\n    cout &#x3C;&#x3C; “FHTAGN !”;\nelse\n    cout &#x3C;&#x3C; “NO”;\n</code></pre>\n<h3>D - Journey</h3>\n<p>● Encontrar o valor esperado de chegar à última cidade.\n● N nós e N-1 arestas com todos os nós conectados\n● O valor esperado tem relação com a probabilidade de se\nalcançar um nó.\n● A definição de valor esperado vem da estatística\n● Por exemplo, a probabilidade de tirar o número 2 em um dado é\n1/6.\n● Se fizermos 30 jogadas é esperado que tire o número 2 cinco\nvezes\n● Se fizermos 40 jogadas o valor esperado para sair o dois no\ndado são 6.67 vezes.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/49e207cf54906cbfaa12f651df52793e/fcbaf/img1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 25.766871165644172%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAn0lEQVR42pVQ0QqEIBD0///PFx+UorIiMTAKKp1jFoo7uAtuYZnVHdeZVfgSpRTBeZ6RUpI654zjOO7er1BPA40x6PsewzDAWgutNWKMH5y/BlZVBe89pmlC13UYxxHbtj0rpJXzPHEhbe37jnVdEUKQYbxn8iP235Nc9og8K+6prmssyyL7or2macQiFVIZVdI68VLKmry2baV2zsnbF7ubg7uRXhUpAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img1' title='' src='/static/49e207cf54906cbfaa12f651df52793e/a6d36/img1.png' srcset='/static/49e207cf54906cbfaa12f651df52793e/222b7/img1.png 163w,\n/static/49e207cf54906cbfaa12f651df52793e/ff46a/img1.png 325w,\n/static/49e207cf54906cbfaa12f651df52793e/a6d36/img1.png 650w,\n/static/49e207cf54906cbfaa12f651df52793e/fcbaf/img1.png 895w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>● O exercício quer o valor esperado para a distância\npercorrida durante a viagem\n● Portanto, a esperança da distância da viagem é a soma das\nprobabilidades de passar em cada aresta</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 566px; '>\n      <a class='gatsby-resp-image-link' href='/static/031359f3df922d33dd6b2e05d9ea8f52/6fe44/img2.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 28.22085889570552%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvElEQVR42qVRywqEMAzs//+VXrwUqYr4tqiISj2IIIqosySgh2VP7sCQkmSmIRHDMGDfdxCu6/qbou97rOv6GB7HgTe4tcK2bZ7QGAOtNZIkged5yLKMmec5XNfFOI6IoghhGKLrOiilUJYliqLg/iAIWC8sy+IJqZimKRzHgZSSxZSjSIbbtiGOYzaq6xq+76NtW1RVxT1kSuaiaRr+kbAsC/MtzvOEmOcZ0zQ9e7gjFe9F0/v7aL9ydJQPV3XKldbG5bEAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img2' title='' src='/static/031359f3df922d33dd6b2e05d9ea8f52/6fe44/img2.png' srcset='/static/031359f3df922d33dd6b2e05d9ea8f52/222b7/img2.png 163w,\n/static/031359f3df922d33dd6b2e05d9ea8f52/ff46a/img2.png 325w,\n/static/031359f3df922d33dd6b2e05d9ea8f52/6fe44/img2.png 566w' sizes='(max-width: 566px) 100vw, 566px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>img3 - img5 (montar gif)\n<img src=\"/static/gif1-3606a50a3b948e8a9ab11622952f2571.gif\" alt=\"gif1\"></p>\n<h3>F - Longest Path on a Tree</h3>\n<p>● Dada uma árvore não direcionada, queremos saber o tamanho\ndo maior caminho entre quaisquer dois nós dela;\n● Este tamanho é o número de arestas percorridas no caminho\nque sai de um nó u e chega em um nó v;\n● Isto configura um problema de cálculo de diâmetro na\nárvore.\n● O diâmetro de uma árvore é o maior comprimento de um caminho entre dois nós;\n● A árvore ao lado possui diâmetro 4, compreendendo o caminho 6 -> 2 -> 1 -> 4 -> 7.</p>\n<p>!{img 7](img7.png)</p>\n<p>● Mas como podemos calcular esse diâmetro máximo?\n● Vamos utilizar Programação Dinâmica!\n● Para tal, escolhemos uma raiz para a árvore a partir de um nó arbitrário e resolvemos o problema separadamente para cada sub-árvore.</p>\n<p>!{img8](img8.png)</p>\n<p>● Com a configuração atual da árvore, podemos perceber que, para cada caminho em nossa árvore enraizada, temos um nó que é o ponto mais alto, as raízes das sub-árvores;\n● Assim, podemos calcular, para cada nó u, o comprimento do maior caminho que tem como ponto mais alto o nó u.\n● Portanto, a estratégia é, sabendo a altura das sub- árvores de cada filho, basta selecionar as duas maiores alturas, somá-las e guardar a soma máxima, representando o diâmetro máximo;\n● Nossa PD será um vetor das alturas, height[n], com height[u] = altura da sub-árvore u, ou seja, o comprimento máximo do nó u para qualquer folha.</p>\n<p>● Recorrência:\n○ Se u é nó folha:\n■ height[u] = 1;\n○ Senão, ∀ v | v é nó filho de u:\n■ height[u] = max(height[u], height[v] + 1)</p>\n<p>img9 - img23 (montar gif)\n<img src=\"/static/gif2-d3093ef6da132176176fab4ee81ce4bb.gif\" alt=\"gif2\"></p>\n<pre><code class=\"language-C++\">int main() {\n    cin >> n;\n    adj = vector&#x3C;vi>(n + 1);\n    for (ll i = 0; i &#x3C; n - 1; i++) {\n        ll u, v;\n        cin >> u >> v;\n        add_edge(u, v);\n    }\n    height = vi(n + 1, 1);\n    diameter = 0;\n    dfs(1, -1);\n    cout &#x3C;&#x3C; diameter &#x3C;&#x3C; \"\\n\";\n    return 0;\n}\n\nll dfs(ll u, ll parent) {\n    ll h1, h2;\n    h1 = h2 = 0;\n    for (auto v : adj[u]) {\n        if (v != parent) {\n            height[u] = max(height[u], dfs(v, u) +\n            1);\n            if (height[v] > h2) {\n                h2 = height[v];\n                if (h2 > h1)\n                    swap(h1, h2);\n            }\n        }\n    }\n    diameter = max(diameter, h1 + h2);\n    return height[u];\n}\n</code></pre>\n<h3>E - Three Paths on a Tree</h3>\n<p>Dada uma árvore, queremos encontrar\ntrês caminhos de forma a conseguir\npassar pelo maior número de vértices\npossíveis.</p>\n<p>!{img 24](img24.png)</p>\n<p>Pseudocódigo:</p>\n<ol>\n<li>Calcular o diâmetro da árvore salvando as posições que</li>\n</ol>\n<p>fazer parte do mesmo</p>\n<pre><code>a. Se o diâmetro for igual ao tamanho da árvore:\n\tcout &#x3C;&#x3C; diâmetro &#x3C;&#x3C; diam[0] &#x3C;&#x3C; diam[1] &#x3C;&#x3C; diam.back();\nb. Senão, passamos por cada um dos nós pertencentes ao diâmetro e\ncalculamos a distância de cada uma delas em relação aos seus\nfilhos, ou seja até a folha, salvando a folha\n\tcout &#x3C;&#x3C; diametro + max_dist &#x3C;&#x3C; diam[0] &#x3C;&#x3C; max_folha &#x3C;&#x3C; diam.back();\n</code></pre>"}},"pageContext":{"id":"9d48a564-8953-5c7a-8095-4cc33e724607","frontmatter__slug":"exercicios-viii","__params":{"frontmatter__slug":"exercicios-viii"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}