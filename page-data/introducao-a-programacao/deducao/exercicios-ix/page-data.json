{"componentChunkName":"component---src-pages-introducao-a-programacao-deducao-markdown-remark-frontmatter-slug-tsx","path":"/introducao-a-programacao/deducao/exercicios-ix/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Exercícios IX","description":"descricao","author":null},"html":"<h2>Resolução dos Exercícios</h2>\n<h3>B - Ancient Berland Roads</h3>\n<p>● São dadas N cidades e M rotas bidirecionais\n● Com o passar do tempo existem queries que tiram estradas\n● E também queries que mudam a população de uma cidade\n● Em cada querie printar a máxima população de um grupo de cidades\n● Problema off querie\n● Cada mudança de população salvar nas queries a pop_antiga - pop_nova\n● Se tenho uma população 3 na cidade e mudar para 5\n● Salvar 3 - 5 = - 2 na querie de mudança de população\n● Usar um multiset pra escolher a cidade com maior população\n● Se aparecer uma querie P tem que retirar a população daquele conjunto\nde cidades do multiset\n● Colocar a população de novo com o valor atualizado\n● Em cada querie printar o valor mais alto no multiseto</p>\n<p>img1 - img15 (montar gif)\n<img src=\"/static/gif1-c816bb03b7aad37a7b5f3fc2314232a3.gif\" alt=\"gif1\"></p>\n<h3>D - Almost Union-Find</h3>\n<p>● Implementar uma estrutura de dados que permite as\nseguintes operações:</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/2c5f8f40e3d3f36eee7c6d9247ada247/7af19/img16.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 20.858895705521473%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAx0lEQVR42lWQWQuDMBCE/f//y2dTBFubaLzwiPeJb9PdhUL7MCxhk29m4jnnEEURuq5DU9d4Pl9o2xau7zGOI9qmwTAMmKZJzkliYK1FT/t5nkkT1nUlLWCWdxwH7vvGvu+4rgvLsghEa408zxGGIQFSVFWFoihEhnb6rX+MBnnHoTwGneeJbdtkfoFpkghEKQVjDLIsI1moIIDNcjFJKSnvArpTUztu8AfktJzSkdNDPSRNHMcirur7vnwPp+I0ZVnK5CZf4AeYCCdTGvUCNAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img16' title='' src='/static/2c5f8f40e3d3f36eee7c6d9247ada247/a6d36/img16.png' srcset='/static/2c5f8f40e3d3f36eee7c6d9247ada247/222b7/img16.png 163w,\n/static/2c5f8f40e3d3f36eee7c6d9247ada247/ff46a/img16.png 325w,\n/static/2c5f8f40e3d3f36eee7c6d9247ada247/a6d36/img16.png 650w,\n/static/2c5f8f40e3d3f36eee7c6d9247ada247/e548f/img16.png 975w,\n/static/2c5f8f40e3d3f36eee7c6d9247ada247/3c492/img16.png 1300w,\n/static/2c5f8f40e3d3f36eee7c6d9247ada247/7af19/img16.png 1359w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>● São dados N elementos, com valores de 1 até N, e M\ncomandos;\n● Inicialmente, cada Ni elemento pertence a um subconjunto\ndistinto;\n● Para cada comando Mi, modificar a estrutura conforme as\nações de cada comando na tabela.</p>\n<p>img17 - img33 (montar gif)\n<img src=\"/static/gif2-f7df2a2d021527b27364b5f10d50f7be.gif\" alt=\"gif2\"></p>\n<pre><code class=\"language-C++\">int main() {\n    int n, m;\n    while (cin >> n >> m) {\n        init();\n        while (m--) {\n            int c, p, q;\n            cin >> c >> p;\n            if (c != 3) {\n                cin >> q;\n                c == 1 ? unite(p, q) : move(p, q);\n            } else {\n                p = find(p);\n                cout &#x3C;&#x3C; len[p] &#x3C;&#x3C; \" \" &#x3C;&#x3C; sum[p] &#x3C;&#x3C; \"\\n\";\n            }\n        }\n    }\n    return 0;\n}\nvoid init() {\n    parent = len = sum = vi(2 * n + 1);\n    for (int u = 1; u &#x3C;= n; u++) {\n        parent[u] = parent[u + n] = u + n;\n        len[u + n] = 1;\n        sum[u + n] = u;\n    }\n}\nint find(int u) {\n    if (u == parent[u])\n        return u;\n    return parent[u] = find(parent[u]);\n}\nvoid unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) {\n        if (len[u] &#x3C; len[v])\n            swap(u, v);\n        parent[v] = u;\n        len[u] += len[v];\n        sum[u] += sum[v];\n    }\n}\nvoid move(int u, int v) {\n    int p;\n    p = find(u);\n    v = find(v);\n    if (p != v) {\n        parent[u] = v;\n        len[p]--;\n        sum[p] -= u;\n        len[v]++;\n        sum[v] += u;\n    }\n}\n</code></pre>"}},"pageContext":{"id":"87463cf1-a49d-5bb0-b5f2-e94b8c3b63f8","frontmatter__slug":"exercicios-ix","__params":{"frontmatter__slug":"exercicios-ix"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}