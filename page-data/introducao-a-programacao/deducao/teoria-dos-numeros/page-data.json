{"componentChunkName":"component---src-pages-introducao-a-programacao-deducao-markdown-remark-frontmatter-slug-tsx","path":"/introducao-a-programacao/deducao/teoria-dos-numeros/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Introdução à Teoria dos Números","description":"descricao","author":"Pedro Henrique Paiola, Rene Pegoraro, Wilson M Yonezawa, Arissa Yoshida, Nicolas Barbosa Gomes, Luis Henrique Morelli"},"html":"<h3>BigInteger</h3>\n<p>• Certos problemas da Maratona de Programação recebem como entrada\nnúmeros inteiros que extrapolam o limite de variáveis do tipo long long\nint\n• Tamanho de uma variável long long int: 8 bytes\n• Intervalo de números que podem ser armazenados em uma variável desse\ntipo:\n• -9.223.372.036.854.775.808 à 9.223.372.036.854.775.807\n• 0 à 18.446.744.073.709.551.615 (unsigned long long int)</p>\n<p>Certos problemas da Maratona de Programação recebem como entrada\nnúmeros inteiros que extrapolam o limite de variáveis do tipo long long\nint\n• Exemplo: 2667 - Jogo de Boca\n• Entrada: 𝑁 (3 ≤ 𝑁 ≤ 10¹⁰⁰)</p>\n<p>• 1ª Situação: dependendo das operações necessárias de se fazer com o\nnúmero, podemos ler o número como sendo uma string e trabalhar com\nessa string.\n• Exemplos:\n• Operações simples com dígitos\n• Uso de Aritmética Modular</p>\n<p>• 2ª Situação: se precisarmos fazer operações com esse número como\nsoma, subtração, multiplicação e divisão, o problema se torna mais\ncomplexo.\n• Nesses casos, não recomendamos usar a linguagem C++. É possível\ntrabalhar com BigInteger em C++ (a biblioteca do Thiago traz códigos\npara isso), porém a quantidade de código necessária é relativamente\ngrande.\n• Sugestões: Java ou Python</p>\n<p>• Em Java podemos usar a classe BigInteger da biblioteca java.math</p>\n<pre><code class=\"language-Java\">String Num;\nBigInteger NumGrande;\nScanner S = new Scanner(System.in);\nNum = S.nextLine();\nNumGrande = new BigInteger(Num);\nNumGrande = NumGrande.mod(new BigInteger(\"3\"));\nSystem.out.println(NumGrande);\n</code></pre>\n<p>• Em Python, não precisamos nos preocupar muito com o tamanho de um\ninteiro, a memória é alocada conforme o necessário para comportar o\ntamanho do número.\n<a href=\"https://www.geeksforgeeks.org/python-input-methods-competitive-programming/\">Entrada e Saída em Python</a>\n<a href=\"https://www.geeksforgeeks.org/python-input-methods-competitive-programming/\">Python em Programação Competitiva</a>\n<a href=\"https://www.geeksforgeeks.org/python-input-methods-competitive-programming/\">Muita coisa sobre Python</a></p>\n<p>• Em Python, não precisamos nos preocupar muito com o tamanho de um\ninteiro, a memória é alocada conforme o necessário para comportar o\ntamanho do número.</p>\n<pre><code class=\"language-Python\">U = int(input())\nprint(U % 3)\n</code></pre>\n<h3>Teoria dos Números</h3>\n<p>• A Teoria dos Números é o ramo da matemática que se preocupa com as\npropriedades dos números inteiros.\n• Existe uma coleção de algoritmos interessantes derivados de estudos da\nTeoria dos Números que solucionam problemas de forma inteligente e\neficiente.\n• Aqui faremos uma breve introdução à alguns tópicos relativos à Teoria\ndos Números.</p>\n<h4>Números primos</h4>\n<p>• Diversos problemas envolvem o uso de números primos.\n• Dessa forma, precisamos, inicialmente, de uma forma de testar se um\nnúmero é primo ou não.\n• Recordando: números primos são números naturais que têm apenas dois\ndivisores: 1 e ele mesmo.</p>\n<p>• Algoritmo ingênuo 𝑂(𝑛)</p>\n<pre><code class=\"language-C++\">bool ehPrimo(int n)\n{\n    for(int i = 2; i &#x3C; n; i++)\n    if (n % i == 0)\n        return false;\n    return true;\n}\n</code></pre>\n<p>• Porém, na verdade só precisamos testar até 𝒏\n• Demonstração:\nSuponha que não, nesse caso existe 𝒏 tal que o menor fator primo 𝒑 de 𝒏\né maior que sqrt(𝒏).\nSe 𝒑 divide 𝒏, então 𝒏/𝒑 também divide 𝒏, e 𝒏/𝒑 deve ser maior que sqrt(n).\nMas se 𝒑 > sqrt(n) e 𝒏/𝒑 > sqrt(n) , então 𝒑 . 𝒏/𝒑 > 𝒏, o que é um absurdo!</p>\n<p>Algoritmo 𝑂( sqrt(𝑛))</p>\n<pre><code class=\"language-C++\">bool ehPrimo(int n)\n{\n    for(int i = 2; i*i &#x3C;= n; i++)\n        if (n % i == 0)\n            return false;\n    return true;\n}\n</code></pre>\n<h3>Crivo de Eratóstenes</h3>\n<p>• O Crivo de Eratóstenes é um método de encontrar os números primos até\num certo valor limite.\n• Útil em casos que faremos vários testes de primalidade e na fatoração de\nnúmeros.\n• Ideia geral: dado que um número 𝒑 é primo, marcamos os múltiplos de 𝒑\ncomo não sendo números primos.</p>\n<p>• Algoritmo:\n• Cria-se uma lista de 2 a 𝑀𝐴𝑋, marcando todos como primos\n• Para cada número 𝑖 de 2 até sqrt(𝑀𝐴𝑋)\n• Se 𝑖 está marcado como primo\n• Marcar todos os números múltiplos de 𝑖 a partir de 𝑖. 𝑖 como compostos (não\nprimos)</p>\n<p>Por que podemos marcar só a partir de 𝑖. 𝑖?\n• Antes de 𝒊. 𝒊 temos: 𝑖. 2, 𝑖. 3, 𝑖. 4, … 𝑖. (𝑖 − 1). Ou ainda, 𝒊. 𝒋 | 𝟐 ≤ 𝒋 &#x3C; 𝒊\n• Seja 𝒙 = 𝒊. 𝒋, 𝒙 é múltiplo de 𝒊 e também é múltiplo de 𝒋\n• Todo 𝒋 ou é primo, ou é múltiplo de um número primo menor que 𝒊, ou\nseja, um primo já “descoberto” pelo algoritmo\n• Se 𝒋 é primo\n• Todos os seus múltiplos foram marcados como não primo, inclusive 𝒊. 𝒋\n• Se 𝒋 é múltiplo de um primo 𝒑 &#x3C; 𝒊\n• Então ele já foi marcado como composto, por ser múltiplo de 𝒑, assim como todos\nos seus múltiplos\n• Logo, todos os números 𝒊. 𝒋 | 𝟐 ≤ 𝒋 &#x3C; 𝒊 já foram marcados</p>\n<pre><code class=\"language-C++\">bool ehPrimo[MAX];\nvector&#x3C;int> primos;\nvoid crivo(int n){\n    memset(ehPrimo, true, sizeof(ehPrimo));\n    for(int p = 2; p * p &#x3C;= n; p++){\n        if (ehPrimo[p]){\n            primos.push_back(p); //Lista incompleta, primos até sqrt(n)\n            for(int i = p*p; i &#x3C;= n; i += p)\n            ehPrimo[i] = false;\n        }\n    }\n}\n</code></pre>\n<p>img1 - img6\n<img src=\"/static/gif1-e08da4be4e83d51729c742a0c017db20.gif\" alt=\"gif1\"></p>\n<p>• Este algoritmo possui complexidade 𝑂(𝑛 log log 𝑛)\n• Esta demonstração não é muito simples. Caso queira conferir, veja o\nartigo do <a href=\"https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#toc-tgt-1\">CP-Algorithms</a>.\n• Com certas otimizações ainda é possível obter um <a href=\"https://cp-algorithms-brasil.com/Algebra/Crivo2.html\">algoritmo de\ncomplexidade linear</a>.</p>\n<h3>Fatoração</h3>\n<p>• Fatoração em 𝑂(sqrt(𝑛))</p>\n<pre><code class=\"language-C++\">vector&#x3C;int> fatorar(int n) {\n    vector&#x3C;int> fator;\n    for (int i = 2; i*i &#x3C;= n; i++){\n        while (n % i == 0){\n            fator.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1)\n    fator.push_back(n);\n    return fator;\n}\n</code></pre>\n<p>• Também é possível obter um algoritmo de fatoração com complexidade\n𝑂(log 𝑛), baseando-se no Crivo de Eratóstenes.\n• Primeiramente, ao invés de utilizarmos o crivo para descobrirmos todos\nos primos, faremos uma pequena alteração para computar para cada\nnúmero o seu Menor Fator Primo (Shortest Prime Factor - SPF).</p>\n<p>• Crivo para Fatoração</p>\n<pre><code class=\"language-C++\">int spf[MAXN];\nvoid crivo(){\n    for(int i=2; i &#x3C; MAXN; i++){\n        if(spf[i] == 0){\n            spf[i] = i;\n            for(int j=i*i; j&#x3C;MAXN; j+=i){\n                if(spf[j] == 0) spf[j] = i;\n            }\n        }\n    }\n}\n</code></pre>\n<p>• A partir do vetor SPF pré-calculado, podemos realizar a fatoração de um\nnúmero qualquer seguindo o seguinte algoritmo:\n• fatores = []\n• enquanto n > 1\n• Inserir spf[n] em fatores\n• n = n/spf[n]</p>\n<h4>Fatoração em 𝑂(log 𝑛)</h4>\n<pre><code class=\"language-C++\">vector&#x3C;int> fatorar(int n){\n    vector&#x3C;int> fator;\n    while(n > 1){\n        fator.push_back(spf[n]);\n        n /= spf[n];\n    }\n    return fator;\n}\n</code></pre>\n<h3>Look-up tables</h3>\n<p>• Existem casos onde podemos gerar um vetor ou matriz de consulta\nmanualmente (ou previamente por outro programa), e inseri-los prontos\nno nosso código. Dessa forma, economiza-se o tempo de gerar tal\nvetor/matriz.\n• Por exemplo, se para resolver um problema precisamos de todos os\nprimos até 𝑁, podemos embutir um vetor de primos já dentro do código.</p>\n<pre><code class=\"language-C++\">int primos[] = {2, 3, 5, 7, 11, 13, … }\n</code></pre>\n<p>• Isso também pode ser gerado por um programa auxiliar.</p>\n<p>“The judge can’t look into your heart or your program\nto see your intentions - it only checks the results.”\n(Skiena &#x26; Revilla, 2003; p. 129)</p>\n<h3>Máximo Divisor Comum</h3>\n<p>• Problema: encontrar o maior divisor comum de um par de números.\n• Algoritmo de Euclides\n• OBS: se 𝑚𝑑𝑐(𝑥, 𝑦) = 1, então dizemos que 𝑥 e 𝑦 são coprimos ou primos\nentre si.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/646b41c5f3e9acda4023fbe1f7a96dcc/4ad3a/img7.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 54.601226993865026%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACTklEQVR42n2Sy09TURCHD4+GFiqUFoQGJDGKmvgPuFKjCzTRxBUuFBBEXrW9bTHVuEJdGIOxAWyCJCSCgDXi0gTdumWnEaMCTXxE4wOD0rT39XnutURQdJLJzL33zDe/mXvE1NQkC/MLWGZoOrqqoqpZTJlruVy33msa2WzmL1flGcMwefrmE7PPXiDQTVI/PjK79Jq5729ZzH5lPvOZlLrEB3WZ99oyi5kvvMsuYWDyL9Nkw3Q6LYHSMrrKN22FFS3No5k4Q2MdJCZ7GEkGuXUvRCIZYFjmd6bPMTEdY+J+jNGpME8eD4Cp223MXDMbiGnK7nZC7OpBxEmBu8OBsz0fR1seoln88iZhfytozkc0CkKX91h7Qs8xfgNZBUIsfhhxRuAJl1Ma8lBy1i1jGa5AMZuCpZQrXrwRH3ldDpT+vRJobABco/Bi/AjOQIld5Oxx5ryIopy7Ai7ZpBjRIYj275NA/f/AvoGjVHeWUR+uwR+upCJSgUcq9YW9+CJSXdRLpXx2tAp6rx+wgcZGQD038oUbDYgWQWFnAW6p1N/rpyq6GW/Qi1/xU9O9lcJ2h31GsRSaf4xsyB0Yuo4qo7WP8/FDiDaBo8cl9yjVRCopU0rxdFVQ1b1Nxiqc3S7EaQu437ovsta0GRZr/ciy27XEMWqDbnbHPOyMVrNdjrcjWk59yM0uxU2d4qMuvIVa+aMuxRuQN379yC9Tz1n1V9JnHlxhcqSF5Ggj48OnGEu0MDHSynjiBHdvHmd0qI3hwU5uDzbxMNkna+ZYy/gJmet+/SYj6zUAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img7' title='' src='/static/646b41c5f3e9acda4023fbe1f7a96dcc/a6d36/img7.png' srcset='/static/646b41c5f3e9acda4023fbe1f7a96dcc/222b7/img7.png 163w,\n/static/646b41c5f3e9acda4023fbe1f7a96dcc/ff46a/img7.png 325w,\n/static/646b41c5f3e9acda4023fbe1f7a96dcc/a6d36/img7.png 650w,\n/static/646b41c5f3e9acda4023fbe1f7a96dcc/e548f/img7.png 975w,\n/static/646b41c5f3e9acda4023fbe1f7a96dcc/4ad3a/img7.png 1152w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h4>MDC/GCD em 𝑂(log(𝑎 + 𝑏))</h4>\n<pre><code class=\"language-C++\">int gcd(int a, int b){\n    if (a == 0)\n        return b;\n    return gcd(b % a, a);\n}\n</code></pre>\n<p>• Problema: encontrar o menor múltiplo comum entre um par de inteiros.\n• Para encontrar o mmc(x, y), podemos calcular o mdc(x, y) e utilizar a\nseguinte fórmula:\n𝑚𝑚𝑐(𝑥, 𝑦) ∗ 𝑚𝑑𝑐(𝑥, 𝑦) = 𝑥 ∗ 𝑦\nOu seja:\n𝑚𝑚𝑐(𝑥, 𝑦) = 𝑥 ∗ 𝑦 / 𝑚𝑑𝑐(𝑥, 𝑦)</p>\n<h4>MMC/LCM em 𝑂(log(𝑎 + 𝑏))</h4>\n<pre><code class=\"language-C++\">int lcm(int a, int b){\n    return a * (b / gcd(a, b));\n}\n</code></pre>\n<h4>Equações diofantinas</h4>\n<p>• Podemos definir uma equação diofantina linear como uma equação da\nforma\n𝒂𝟏𝒙𝟏 + 𝒂𝟐𝒙𝟐 + ⋯ + 𝒂𝒏 𝒙𝒏 = 𝒄\nsendo 𝒂𝟏, … , 𝒂𝒏 coeficientes inteiros não nulos, 𝒙𝟏 … , 𝒙𝒏 as variáveis\ninteiras a serem determinadas e 𝒄 uma constante inteira.\n• Diversos problemas podem ser modelados usando equações diofantinas.\nEm especial, vamos nos preocupar com equações diofantinas de duas\nvariáveis\n𝒂𝒙 + 𝒃𝒚 = 𝒄</p>\n<h4>Equações diofantinas – Fantastic Beasts</h4>\n<p>• Exemplo de Problema: Fantastic Beasts (Final da Maratona SBC de\nProgramação - 2018)\n• Resumindo: considere um grafo direcionado em que os vértices\nrepresentam zoológicos, e cada zoológico aponta para apenas para um\noutro zoológico (grau de saída = 1). Temos animais espalhados por esses\nzoológicos, e a cada unidade de tempo todos os animais avançam para\no próximo zoológico.\n• Objetivo: determinar onde e quando TODOS os animais se encontrarão,\nno mesmo zoológico ao mesmo tempo (se isso puder ocorrer em diversos\nmomentos e locais, determinar o primeiro deles)\n• Supondo que já estamos em uma fase um pouco mais avançada no\nproblema, onde conseguimos modelar para cada zoológico z uma\nequação que determina os momentos em que um animal a passa por lá\n(os animais vão acabar presos em ciclos).\n𝑡 = 𝑡0 + 𝑘. 𝑖</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/13d1b23ee559393302b62ae695bc5ebf/cd536/img8.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.44171779141104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB2ElEQVR42o1Sa2/aQBDk//8bfkEfaVPaKgEClWgwENRgZIPt8z3sww+ms0eC+gWpJ6/W3l3P7OzeYDgcIlqtIKfrOvR9j77r0XYtv/sQO/fn4Ju2Dbn3fPuWA5/F7oCH+QIDAfpTH/FTRXgs1xjTFvYVE73BzGwvMb2G7Tx+uzjkfxRLRG4fcg/MvdQpQc+BJAAKc2FLZKZE4Qy01TDOIisLKKOh+O2cgyoVrK9gTxUq+pLxTBehvmmaoDIA+tpjPp/j1/QJ2+kUs9kMaZrgcDigyHOoogg+SZIAXFUVtNbIGTuyJs/yELsCZlmGZRRh9fyMbLeD9x6lKmH4k7GWas743xMA0zTFcsm5RCu87uNAkLIb6Sje7wlqYAksJosQeReSc/D/El4ksyMBEYnZ8UigFEopgsWISLSlrTcbrKmiYJ3Uy2242eGtI0sQooRdioo0jlGQVM6tMVw71LqENiYM23Czrq7guQzHmdYvG9QE9ZTsKVckOy5BFiTjkIVIx0ISAGtXIz/yiijNbZZcCAGtQ9d08BXlnXiJaV3L+XkCnhqSWtbYUGuNu3Y8+Pr4Ad8mn/D96Y72JdiI76PpZ9wzLrn7Cd/H9OOPISZe8qO3f0bTu5AXrL8tJELuF7V3XwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img8' title='' src='/static/13d1b23ee559393302b62ae695bc5ebf/a6d36/img8.png' srcset='/static/13d1b23ee559393302b62ae695bc5ebf/222b7/img8.png 163w,\n/static/13d1b23ee559393302b62ae695bc5ebf/ff46a/img8.png 325w,\n/static/13d1b23ee559393302b62ae695bc5ebf/a6d36/img8.png 650w,\n/static/13d1b23ee559393302b62ae695bc5ebf/e548f/img8.png 975w,\n/static/13d1b23ee559393302b62ae695bc5ebf/cd536/img8.png 1114w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>• Proposição 1: 𝒂𝒙 + 𝒃𝒚 = 𝒄 admite solução sse 𝒈𝒄𝒅(𝒂, 𝒃) | 𝒄\n⇒\n• Sendo (𝑥0, 𝑦0) uma solução da equação\n• Seja 𝑑 = gcd(𝑎, 𝑏), então 𝑑|𝑎 e 𝑑|𝑏. Logo podemos reescrever 𝑎 = 𝐴𝑑 e 𝑏 = 𝐵𝑑</p>\n<p>𝑐 = 𝑎𝑥0 + 𝑏𝑦0 = 𝐴𝑑 𝑥0 + 𝐵𝑑 𝑦0\n𝑐 = 𝑑(𝐴𝑥0 + 𝐵𝑦0)\nDenotando 𝑞 = 𝐴𝑥0 + 𝐵𝑦0</p>\n<p>𝑐 = 𝑑𝑞 Portanto, 𝑑|𝑐</p>\n<p>• Proposição 1: 𝒂𝒙 + 𝒃𝒚 = 𝒄 admite solução sse 𝒈𝒄𝒅(𝒂, 𝒃) | 𝒄\n⇐\n• Seja 𝑑 = gcd(𝑎, 𝑏)\n• Pelo Teorema de Bézout, existe solução (𝑥0, 𝑦0) para 𝑎𝑥 + 𝑏𝑦 = 𝑑\n• Por hipótese, 𝑑|𝑐 ⇒ ∃𝑡 / 𝑐 = 𝑑𝑡</p>\n<p>𝑐 = 𝑑𝑡\n𝑐 = (𝑎𝑥0 + 𝑏𝑦0)𝑡\n𝑐 = 𝑎(𝑥0𝑡) + 𝑏(𝑦0𝑡)</p>\n<p>Portanto, se 𝑑 | 𝑐, então a equação 𝑎𝑥 + 𝑏𝑦 = 𝑐 admite solução</p>\n<p>• Como determinar uma solução?</p>\n<ol>\n<li>Obter uma solução (𝑥0, 𝑦0) para 𝑎𝑥 + 𝑏𝑦 = gcd(𝑎, 𝑏)</li>\n<li>Para 𝑎𝑥 + 𝑏𝑦 = 𝑐:</li>\n</ol>\n<p>a) 𝑡 = 𝑐/𝑑 em que 𝑑 = gcd(𝑎, 𝑏)\nb) 𝑥 = 𝑥0𝑡\nc) 𝑦 = 𝑦0𝑡\n3. Se uma equação diofantina tem uma solução, então ela tem infinitas:</p>\n<p>• Solução para 𝑎𝑥 + 𝑏𝑦 = gcd(𝑎, 𝑏)</p>\n<ol>\n<li>Caso base (𝑎 = 0):</li>\n</ol>\n<p>• Se 𝑎 = 0 então temos 𝑏𝑦 = gcd(0, 𝑏)\n• Sabemos que gcd 0, 𝑏 = 𝑏\n• Então 𝑏𝑦 = 𝑏, logo 𝑦 = 1\n• Nesse caso 𝑥 pode assumir qualquer valor. Como queremos uma solução qualquer,\npor motivos de simplificação, faremos 𝑥 = 0\n• Solução base: (0, 1)</p>\n<p>• Solução para 𝑎𝑥 + 𝑏𝑦 = gcd(𝑎, 𝑏)</p>\n<ol start=\"2\">\n<li>Passo da indução:</li>\n</ol>\n<p>• Temos 𝑎𝑥 + 𝑏𝑦 = gcd(𝑎, 𝑏)\n• Pelo Algoritmo de Euclides, sabemos que\ngcd 𝑎, 𝑏 = gcd 𝑏%𝑎, 𝑎 = 𝑑\n• Logo, podemos obter outra equação diofantina:\n𝑏%𝑎 𝑥1 + 𝑎𝑦1 = 𝑑 (∗)</p>\n<p>• Solução para 𝑎𝑥 + 𝑏𝑦 = gcd(𝑎, 𝑏)\n• Considerando o resultado da divisão inteira, podemos dizer que:\n𝑏 = 𝑏\n𝑎 𝑎 + 𝑏%𝑎\n𝑏%𝑎 = 𝑏 − 𝑏\n𝑎 𝑎\n• Substituindo em (∗)\n𝑏 − 𝑏\n𝑎 𝑎 𝑥1 + 𝑎𝑦1 = 𝑑\n𝑏𝑥1 − 𝑏\n𝑎 𝑎𝑥1 + 𝑎𝑦1 = 𝑑\n𝑎 𝑦1 − 𝑏\n𝑎 𝑥1 + 𝑏𝑥1 = 𝑑\n𝒂𝒙 + 𝒃𝒚 = 𝒅</p>\n<h4>Implementação</h4>\n<pre><code class=\"language-C++\">int gcd(int a, int b, int &#x26;x, int &#x26;y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int d = gcd(a, b % a, x1, y1);\n    x = y1 - x1 * (b/a);\n    y = x1;\n    return d;\n}\n\nbool solve(int a, int b, int c, int &#x26;x0, int &#x26;y0, int &#x26;g) {\n    g = gcd(abs(a), abs(b), x0, y0);\n    if (c % g) {\n        return false;\n    }\n    x0 *= c / g;\n    y0 *= c / g;\n    if (a &#x3C; 0) x0 = -x0;\n    if (b &#x3C; 0) y0 = -y0;\n    return true;\n}\n</code></pre>\n<h3>Aritmética Modular</h3>\n<p>• Em vários problemas precisamos operar com os restos de divisões de\ninteiros.\n• A aritmética modular permite fazer cálculos com restos de divisões de\nmodo eficiente, e é especialmente útil quando estamos trabalhando com\nnúmeros grandes (BigInteger).\n• Na verdade, a Aritmética Modular pode nos ajudar a evitar ter que\ntrabalhar com números muito grandes.</p>\n<p>• A aritmética modular se baseia nas seguintes propriedades:\n(𝑥 + 𝑦) % 𝑛 = ((𝑥 % 𝑛) + (𝑦 % 𝑛)) % 𝑛\n(𝑥 − 𝑦) % 𝑛 = ((𝑥 % 𝑛) − (𝑦 % 𝑛)) % 𝑛\n(𝑥 ∗ 𝑦) % 𝑛 = ((𝑥 % 𝑛) ∗ (𝑦 % 𝑛)) % 𝑛\n(𝑥 ^ 𝑦) % 𝑛 = ((𝑥 % 𝑛) ^ 𝑦) % 𝑛</p>\n<p>• UVa 374 - Big Mod\n• Calcule 𝑅 = 𝐵𝑃 𝑚𝑜𝑑 𝑀\n• 0 ≤ 𝐵, 𝑃 ≤ 2147483647 e 1 ≤ 𝑀 ≤ 46340</p>\n<p>• Parte da solução do problema UVA 374 – Big Mod</p>\n<pre><code class=\"language-C++\">long long pow(long long x, long long y, long long mod) {\n    if (y == 0)\n        return 1;\n    long long p = pow(x, y/2, mod);\n    if (y % 2 == 0)\n        return (p * p) % mod;\n    else\n        return (((p * p) % mod) * (x % mod)) % mod;\n}\n</code></pre>\n<h3>Inverso Modular</h3>\n<p>• A aritmética modular não se aplica a divisão. Porém, temos o conceito de\ninverso multiplicativo modular.\n• Lembre-se que um número multiplicado pelo seu inverso é igual a 1\n• Da aritmética básica, sabemos que:\n• O inverso de um número 𝐴 é 1\n𝐴\n• Todos os reais diferentes de 0 têm um inverso\n• Multiplicar um número pelo inverso de 𝐴 é o mesmo que dividir por 𝐴\n• 𝑋 ∗ 𝐴−1 = 𝑋 ∗ 1\n𝐴 = 𝑋\n𝐴</p>\n<p>• O inverso modular de 𝐴 (𝑚𝑜𝑑 𝐶) é 𝐴−1.\n• 𝐴 ∗ 𝐴−1 ≡ 1 (𝑚𝑜𝑑 𝐶) ou de modo equivalente 𝐴 ∗ 𝐴−1 𝑚𝑜𝑑 𝐶 = 1\n• OBS: Apenas os números coprimos de C têm um inverso modular (mod C)o</p>\n<p>• Exemplo: A=3 e C=7\n3 ∗ 5 𝑚𝑜𝑑 7 = 15 𝑚𝑜𝑑 7 = 1\n∴ 3 ∗ 5 ≡ 1 (𝑚𝑜𝑑 7)\n• Logo, 5 é o inverso modular de 3 (mod 7) .</p>\n<p>• Como encontrar um inverso multiplicativo?\n• Determinar um 𝑥 ∈ ℤ tal que 𝐴𝑥 ≡ 1 𝑚𝑜𝑑 𝐶 ⇒ 𝑥 = 𝐴−1\n• Da congruência, temos que\n• C | (𝐴𝑥 − 1)\n• Logo, ∃y ∈ ℤ| 𝐴𝑥 − 1 = 𝐶𝑦\n𝐴𝑥 − 𝐶𝑦 = 1\n• Equação diofantina!</p>\n<h3>Referências</h3>\n<p>Biblioteca de códigos de Thiago Alexandre Domingues de Souza.\nMatemática Discreta e Suas Aplicações. Kenneth H. Rosen.\nProgramming Challenges: The Programming Contest Training Manual. Stevem S. Skiena e\nMiguel A. Revilla.\n<a href=\"https://www.geeksforgeeks.org/sieve-of-eratosthenes/\">https://www.geeksforgeeks.org/sieve-of-eratosthenes/</a>\n<a href=\"http://www.lcad.icmc.usp.br/~jbatista/scc210/AulaTeoriadosNumeros1.pdf\">http://www.lcad.icmc.usp.br/~jbatista/scc210/AulaTeoriadosNumeros1.pdf</a>\n<a href=\"http://www.lcad.icmc.usp.br/~jbatista/scc210/AulaTeoriadosNumeros2.pdf\">http://www.lcad.icmc.usp.br/~jbatista/scc210/AulaTeoriadosNumeros2.pdf</a>\n<a href=\"https://www.ufsj.edu.br/portal2-repositorio/File/comat/tcc_Ricardo.pdf\">https://www.ufsj.edu.br/portal2-repositorio/File/comat/tcc_Ricardo.pdf</a>\n<a href=\"https://cp-algorithms.com/algebra/linear-diophantine-equation.html\">https://cp-algorithms.com/algebra/linear-diophantine-equation.html</a>\n<a href=\"https://noic.com.br/materiais-informatica/curso/math-02/\">https://noic.com.br/materiais-informatica/curso/math-02/</a>\n<a href=\"https://noic.com.br/materiais-informatica/curso/math-03/\">https://noic.com.br/materiais-informatica/curso/math-03/</a>\n<a href=\"https://pt.khanacademy.org/computing/computer-\">https://pt.khanacademy.org/computing/computer-</a>\nscience/cryptography/modarithmetic/pi/fast-modular-exponentiation\n<a href=\"https://www.cin.ufpe.br/~gdcc/matdis/aulas/aritmeticaModular_parte2.pdf\">https://www.cin.ufpe.br/~gdcc/matdis/aulas/aritmeticaModular_parte2.pdf</a></p>"}},"pageContext":{"id":"5841cff8-6a65-5e6d-b6e7-f0826f61fc0c","frontmatter__slug":"teoria-dos-numeros","__params":{"frontmatter__slug":"teoria-dos-numeros"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}