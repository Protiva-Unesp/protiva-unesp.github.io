{"componentChunkName":"component---src-pages-introducao-a-programacao-deducao-markdown-remark-frontmatter-slug-tsx","path":"/introducao-a-programacao/deducao/exercicios-10/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"02 - Exercícios","description":"descricao","author":null},"html":"<h2>Explicação dos Exercícios de Grafo</h2>\n<h3>Exercícios B, D e G</h3>\n<h3>B - Find the Treasure</h3>\n<ul>\n<li>Confira a GIF abaixo</li>\n</ul>\n<p><img src=\"/static/gif1-96f22cdd86bb32c9c2cf47e7061c9a03.gif\" alt=\"img1-img7\"></p>\n<h3>BFS partindo de múltiplas fontes</h3>\n<ul>\n<li>Seu funcionamento é exatamente igual ao da BFS.</li>\n<li>No entanto, ao invés de começar em um único nó, todos os vértices que considerarmos como ínicio serão inseridos na fila de processamento.</li>\n<li>Útil para resolução de problemas que requerem o cálculo da mínima distância ou custo para se chegar a um vértice.</li>\n</ul>\n<p><img src=\"/static/gif2-8650b5a3e4c12798eb859438c1d89d3c.gif\" alt=\"img8-img18\"></p>\n<pre><code class=\"language-C++\">void bfs(const vector&#x3C;int> &#x26;sources) {\n    queue&#x3C;int> q;\n    vector&#x3C;int> dist;\n    for (auto s : sources) {\n        dist[s] = 0;\n        q.push(s);\n    }\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (auto v : adj[u]) {\n            if (dist[u] + 1 &#x3C; dist[v]) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n}\n</code></pre>\n<h3>D - Police Stations</h3>\n<p>img19 - img33 (montar gif)\n<img src=\"/static/gif3-2a0bb585e771bc806dd1be667bda7b38.gif\" alt=\"img19-img33\"></p>\n<h3>G - Jane and the Frost Giants</h3>\n<ul>\n<li>\n<p>Jane está presa em um labirinto que contém armadilhas de fogo, espalhando uma célula para o lado, nas direções vertical e horizontal, a cada minuto.</p>\n</li>\n<li>\n<p>Jane leva um minuto para andar para uma célula adjacente.</p>\n</li>\n<li>\n<p>Determinar o tempo mínimo para Jane escapar por uma das bordas do labirinto, se possível.</p>\n</li>\n<li>\n<p>Estratégia: computar o tempo mínimo que demora para uma célula pegar fogo a partir de cada armadilha.</p>\n</li>\n<li>\n<p>Após isso, computar o tempo mínimo que leva para Jane alcançar uma célula adjacente e se é possível alcançá-la antes do fogo.</p>\n</li>\n<li>\n<p>Verificar se ela consegue chegar em alguma borda.</p>\n</li>\n<li>\n<p>Confira a GIF abaixo</p>\n</li>\n</ul>\n<p><img src=\"/static/gif4-e8d6099a1316fb1ca256a17f63faaa04.gif\" alt=\"img34-img46\"></p>\n<pre><code class=\"language-C++\">int main() {\n    int T;\n    cin >> T;\n    for (int t = 1; t &#x3C;= T; t++) {\n        cin >> r >> c;\n        grid = vector &#x3C;string >(r + 1);\n        for (int i = 0; i &#x3C; r; i++)\n            cin >> grid[i];\n        vii fire, jane;\n        for (int i = 0; i &#x3C; r; i++) {\n            for (int j = 0; j &#x3C; c; j++) {\n                if (grid[i][j] == 'F')\n                    fire.push_back ({i, j});\n                else if (grid[i][j] == 'J')\n                jane.push_back ({i, j});\n            }\n        }\n        int minutes;\n        dist = vector &#x3C;vi>(r + 1, vi(c + 1, INF));\n        bfs(fire, false);\n        minutes = bfs(jane, true);\n        cout &#x3C;&#x3C; \"Case \" &#x3C;&#x3C; t &#x3C;&#x3C; \": \";\n        if (minutes != INF)\n            cout &#x3C;&#x3C; minutes + 1 &#x3C;&#x3C; \"\\n\";\n        else\n            cout &#x3C;&#x3C; \"IMPOSSIBLE \\n\";\n    }\n    return 0;\n}\nint bfs(const vii &#x26;sources , bool jane) {\n    int minutes = INF;\n    queue&#x3C;ii> q;\n    for (auto [i, j] : sources) {\n        dist[i][j] = 0;\n        q.push({i, j});\n    }\n    while (!q.empty()) {\n        int i, j;\n        tie(i, j) = q.front();\n        q.pop();\n        if (jane &#x26;&#x26; (i == 0 || i == r - 1 || j == 0 || j == c -\n        1))\n            minutes = min(dist[i][j], minutes);\n        for (auto [x, y] : dir) {\n            int a, b;\n            a = i + x;\n            b = j + y;\n            if (a >= 0 &#x26;&#x26; a &#x3C; r &#x26;&#x26; b >= 0 &#x26;&#x26; b &#x3C; c &#x26;&#x26; grid[a][b]\n            == '.' &#x26;&#x26; dist[i][j] + 1 &#x3C; dist[a][b]) {\n                dist[a][b] = dist[i][j] + 1;\n                q.push({a, b});\n            }\n        }\n    }\n    return minutes;\n}\n</code></pre>"}},"pageContext":{"id":"b03f8f65-9e03-595f-9720-df1faab5031c","frontmatter__slug":"exercicios-10","__params":{"frontmatter__slug":"exercicios-10"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}