{"componentChunkName":"component---src-pages-introducao-a-programacao-deducao-markdown-remark-frontmatter-slug-tsx","path":"/introducao-a-programacao/deducao/exercicios-vi/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Exercicios VI","description":"descricao","author":null},"html":"<h2>Resolução dos Exercícios</h2>\n<h2>Exercícios F, H, I</h2>\n<h3>F - Buns</h3>\n<p>● TokiDeBuns, uma chefe de renome, vai fazer vários\npãezinhos doces com diferentes recheios;\n● Vamos chamar esses pãezinhos doces de donuts;\n● Dada uma quantidade de massa N, qual é o valor\nmáximo de lucro que ela consegue com a venda\ndeles ?\n● Ela vai produzir M donuts, cada uma com recheio diferente;\n● Para cada donut i, ela tem ai de recheio disponível, ela precisa de bi unidades de recheio e ci unidades de massa e pode vendê-los pelo valor di;\n● Ela também pode fazer donuts sem recheio, com c0 unidades de massa e vender por d0.\nMassa disponível: 10 unidades\nTipos de Donuts com recheio: 2 sabores</p>\n<p>img1 - img25\n<img src=\"/static/gif1-a8ee2ac82e2a68d4d9dc101a7a5139f5.gif\" alt=\"gif1\"></p>\n<p>● Podemos observar a seguinte recorrência:\n○ dp[i] = max(dp[i], dp[i - w[j] * k] + c[j] * k);\n○ c[j] * k &#x3C;= i;\n○ k variando de 0 até a[j] / b[j].</p>\n<p>● Onde o índice i são todos as possíveis quantidades\nde massa até N, j são todos os tipos de donuts e\nk a quantidade de donuts i que podem ser feitas\ncom o recheio disponível.</p>\n<pre><code class=\"language-C++\">int main() {\n    int c0, d0;\n    cin >> n >> m >> c0 >> d0;\n    a = b = c = d = vi(m + 1);\n    a[0] = INF;\n    b[0] = 1;\n    c[0] = c0;\n    d[0] = d0;\n    for (int i = 1; i &#x3C;= m; i++)\n        cin >> a[i] >> b[i] >> c[i] >> d[i];\n    cout &#x3C;&#x3C; knapsack() &#x3C;&#x3C; \"\\n\";\n    return 0;\n}\n</code></pre>\n<pre><code class=\"language-C++\">a[0] = INF;\nb[0] = 1;\n</code></pre>\n<p>Essas duas linhas permitem que sejam\ncriadas grandes quantidades de donuts sem\nrecheio.</p>\n<pre><code class=\"language-C++\">int knapsack() {\n    vi dp(n + 1);\n    for (int j = 0; j &#x3C;= m; j++) {\n        for (int i = n; i >= 0; i--) {\n            for (int k = 0; b[j] * k &#x3C;= a[j]; k++) {\n                if (c[j] * k &#x3C;= i)\n                    dp[i] = max(dp[i],\n                        dp[i - c[j] * k] + d[j] * k);\n            }\n        }\n    }\n    return dp[n];\n}\n</code></pre>\n<p>Complexidade: O(N * M * A)\nN -> total de massa\nM -> total de donuts\nA -> recheio disponível</p>\n<h3>H - Longest Regular Bracket Sequence</h3>\n<p>Objetivo: Contar o tamanho da maior sequência correta de\nparênteses.\n-> Devemos contar quantas sequências desse tamanho máximo\nexistem.\n-> Se não houver nenhuma sequência correta printar “0 1”.</p>\n<p>img26 - img49\n<img src=\"/static/gif2-7c89a682bf66f80c14096961036187d5.gif\" alt=\"gif2\"></p>\n<pre><code class=\"language-C++\">#include &#x3C;bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n    string s;\n    cin >> s;\n    s = \"+\" + s;\n    ll tam = s.size();\n    vector&#x3C;ll> dp (tam+1, 0);\n    stack&#x3C;ll> pq;\n    ll ma = 0;\n}\n\nfor(int i = 1; i &#x3C;= tam; i++){\n    if(s[i] == ')'){\n        if(pq.empty())continue;\n        ll val = pq.top(); pq.pop();\n        ll range = i - val + 1;\n        dp[i] = range + dp[val-1];\n        ma = max(ma, dp[i]);\n    }\n    else{\n        pq.push(i);\n    }\n}\nll cont = 0;\nfor(int i = 1; i &#x3C;= tam; i++){\n    if(ma == dp[i])cont++;\n}\nif(ma == 0)cout &#x3C;&#x3C; \"0 1\\n\";\nelse cout &#x3C;&#x3C; ma &#x3C;&#x3C; \" \" &#x3C;&#x3C; cont &#x3C;&#x3C; \"\\n\";\n</code></pre>\n<h3>I - Road Optimization</h3>\n<p>O Governo de Marte está interessado em otimizar o sistema\nde rodovia!\nDado o sistema de uma rodovia de tamanho l, que possui\numa sequência de n placas sendo di sua posição e ai o limite\nde velocidade (min), sendo possível remover até k placas,\nqual o tempo mínimo para se deslocar do ponto 0 até l.</p>\n<pre><code class=\"language-C++\">d.push_back(l);\na.push_back(0);\ndp[0][0] = 0;\nfor (int i = 1; i &#x3C;= n; i++){\n    for (int j = 0; j &#x3C;= k; j++){\n        for (int m = 0; m &#x3C; i; m++){\n            ll removed = j - (i - m - 1);\n            if (removed >= 0)\n            {\n                dp[i][j] = min(dp[i][j], dp[m][removed] + (d[i] - d[m]) * a[m]);\n            }\n        }\n    }\n}\n</code></pre>"}},"pageContext":{"id":"5355e55a-24ce-5169-ae11-f7ebaaa9416e","frontmatter__slug":"exercicios-vi","__params":{"frontmatter__slug":"exercicios-vi"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}