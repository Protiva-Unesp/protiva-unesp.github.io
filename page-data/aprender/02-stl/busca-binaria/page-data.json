{"componentChunkName":"component---src-pages-aprender-02-stl-markdown-remark-frontmatter-slug-tsx","path":"/aprender/02-stl/busca-binaria/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"02 - Busca Binária","description":"descricao","author":null},"html":"<h2>Problema da busca</h2>\n<ul>\n<li>Dada uma coleção de n elementos, determinar se um determinado elemento (valor) está presente nessa coleção e, se sim, qual a posição desse elemento.</li>\n<li>Exemplo: busca em vetor de inteiros</li>\n</ul>\n<pre><code>vet = {2, 5, 7, 8, 10}\nbuscar(vet, 7) = 2 //o elemento 7 está na posição 2 do vetor\nbuscar(vet, 2) = 0 //o elemento 2 está na posição 0 do vetor\nbuscar(vet, 3) = -1 //o elemento 3 não se encontra no vetor\n</code></pre>\n<ul>\n<li>Generalização: dada uma relação R(x, y), o problema da busca consiste em, para um certo valor y, determinar se há um possível valor de x que satisfaça R(x, y), e se sim, retornar este valor.</li>\n</ul>\n<h3>Busca linear</h3>\n<ul>\n<li>1ª solução: busca linear ou sequencial – percorrer o vetor desde a primeira posição até a última em busca de um elemento x:\n<ul>\n<li>Se o elemento for encontrado, retornamos a posição;</li>\n<li>Senão, retornamos -1 (por exemplo) para indicar que o elemento não foi encontrado.</li>\n</ul>\n</li>\n<li>Exemplo de implementação</li>\n</ul>\n<pre><code class=\"language-C++\">int buscaLinear(vector&#x3C;int> vet, int x)\n    {\n    for(int i = 0; i &#x3C; vet.size(); i++)\n    {\n        if (vet[i] == x)\n        return i;\n    }\n    return -1;\n}\n</code></pre>\n<ul>\n<li>Análise da complexidade: no pior caso, em que o elemento não está no</li>\n</ul>\n<p>vetor, teremos que percorrer todas as n posições do vetor.</p>\n<ul>\n<li>Sendo assim, esse algoritmo tem complexidade O(n).</li>\n</ul>\n<h3>Busca linear com dados ordenados</h3>\n<ul>\n<li>Agora suponha que os dados do vetor foram previamente ordenados.</li>\n<li>Com isso conseguimos melhorar um pouco o algoritmo, pois ao buscar um elemento x, se passarmos por um y | y > x, podemos encerrar a busca.</li>\n<li>Exemplo</li>\n</ul>\n<pre><code class=\"language-C++\">vet = {0, 4, 6, 9, 10, … }\n/*Se buscarmos o número 7 nesse vetor (sabendo que ele está ordenado),\nassim que passarmos pela posição 3 vamos saber que ele não se encontra no\nvetor, mesmo que ele tenha mais 100000 elementos*/\n</code></pre>\n<ul>\n<li>Exemplo de implementação</li>\n</ul>\n<pre><code class=\"language-C++\">int buscaLinearOrd(vector&#x3C;int> vet, int x)\n{\n    for(int i = 0; i &#x3C; vet.size(); i++)\n    {\n        if (vet[i] == x)\n        return i;\n    if (vet[i] > x)\n        break;\n    }\n    return -1;\n}\n</code></pre>\n<ul>\n<li>Análise da complexidade: apesar desse algoritmo ser mais “esperto”, se saindo melhor em alguns casos específicos, sua complexidade no pior caso ainda é O(n).</li>\n<li>Pior caso: o número procurado não está no vetor e é maior que o último elemento do vetor.</li>\n</ul>\n<h3>Busca binária</h3>\n<ul>\n<li>Porém, ainda partindo do fato que temos o vetor ordenado, imagine que verificamos inicialmente a posição do meio do vetor (e não a primeira posição, como na busca linear)</li>\n<li>O que podemos concluir disso?</li>\n</ul>\n<pre><code>centro = (inicio + fim) / 2\nSe vet[centro] == x, então o elemento está na posição “centro”\nSe vet[centro] > x, então x só pode estar entre vet[inicio] e vet[centro - 1]\nSe vet[centro] &#x3C; x, então x só pode estar entre vet[centro + 1] e vet[fim]\n</code></pre>\n<ul>\n<li>E qual a vantagem disso? Em uma única verificação eliminamos a necessidade de comparar o elemento buscado com metade do vetor.</li>\n<li>Para a metade onde o elemento x pode estar, aplicamos a mesma ideia, comparando com a posição do meio desse intervalo.</li>\n<li>Confira na GIF abaixo:</li>\n</ul>\n<p><img src=\"/static/gif1-be4228b2688d264ec633b40d5aeb1b10.gif\" alt=\"img1-img8\"></p>\n<ul>\n<li>Exemplo de implementação – versão recursiva:</li>\n</ul>\n<pre><code class=\"language-C++\">int buscaBinaria(int vet[], int esq, int dir, int x)\n{\n    if (esq > dir)\n        return -1;\n    int meio = (esq + dir)/2;\n    if (vet[meio] > x)\n        return buscaBinaria(vet, esq, meio-1, x);\n    if (vet[meio] &#x3C; x)\n        return buscaBinaria(vet, meio+1, dir, x);\n        return meio;\n}\n</code></pre>\n<ul>\n<li>Exemplo de implementação – versão iterativa:</li>\n</ul>\n<pre><code class=\"language-C++\">int buscaBinaria2(int vet[], int n, int x)\n{\n    int esq = 0, dir = n - 1, meio;\n    while(esq &#x3C;= dir) {\n        meio = (esq + dir)/2;\n        if (vet[meio] == x) return meio;\n        if (vet[meio] > x) dir = meio - 1;\n        else esq = meio + 1;\n    }\n    return -1;\n}\n</code></pre>\n<ul>\n<li>Análise da complexidade: não iremos fazer a demonstração formal, mas o fato de dividirmos o intervalo de busca sempre pela metade faz com que a complexidade no algoritmo, no pior caso, seja O(log n). Sendo assim, mais eficiente que a busca linear.</li>\n<li>OBS: NÃO ESQUEÇA que o vetor deve estar ordenado, e um algoritmo assintoticamente ótimo de ordenação tem complexidade O(n.log n).</li>\n</ul>\n<h3>Busca binária “generalizada”</h3>\n<ul>\n<li>A busca binária não se aplica somente a busca em vetores, podendo ser generalizada para diversas aplicações.</li>\n<li>Em Programação Competitiva, em especial, encontraremos diversos problemas que podem ser resolvidos utilizando busca binária.</li>\n</ul>\n<h3>Fase Regional da Maratona 2019</h3>\n<ul>\n<li>\n<p>Problema M: Maratona Brasileira de Comedores de pipocas</p>\n</li>\n<li>\n<p>A competição consiste em N sacos de pipocas colocados lado a lado, onde cada saco possui uma quantidade arbitrária de pipoca.</p>\n</li>\n<li>\n<p>A competição ocorrem em equipes, cada uma composta por C competidores, e cada competidor pode comer, no máximo, até T pipocas por segundos.</p>\n</li>\n<li>\n<p>Cada competidor da equipe deverá comer uma sequência contígua de sacos de pipocas. É perfeitamente válido que um competidor não coma nenhuma pipoca.</p>\n</li>\n<li>\n<p>Todas as pipocas de um mesmo saco devem ser comidas por um único competidor.</p>\n</li>\n<li>\n<p>O objetivo da competição é comer todas as pipocas no menor tempo possível, dado que os C competidores podem comer em paralelo e eles respeitarão todas as regras impostas.</p>\n</li>\n<li>\n<p>Entrada</p>\n</li>\n</ul>\n<pre><code>N = quantidade de sacos de pipocas (&#x3C;= 105)\nC = quantidade de competidores de uma mesma equipe\nT = quantidade máxima de pipoca/s que um competidor pode comer\nPi = quantidade de pipocas no saco i\n</code></pre>\n<ul>\n<li>Solução: vamos partir de um problema mais simples:</li>\n<li>Dado um tempo x, determinar se a equipe é capaz de comer todas as pipocas neste tempo. Por motivos de simplificação, vamos supor T = 1</li>\n<li>Para isso, basta percorrer o vetor e tentar atribuir o máximo de sacos de pipocas para um competidor (enquanto &#x3C; x). Quando não for possível fazer isso, passamos para o próximo competidor.</li>\n<li>Se conseguirmos chegar no final do vetor, respeitando o limite de competidores da equipe, então é possível comer as pipocas no tempo x.</li>\n<li>Esse processo tem complexidade O(N)</li>\n</ul>\n<pre><code class=\"language-C++\">bool ehPossivel(vector&#x3C;int> &#x26;pip, int c, int x){\n    int soma = 0, competidorAtual = 0;\n    for(int i = 0; i &#x3C; pip.size(); i++){\n        soma += pip[i];\n    if (soma > x){\n        competidorAtual++;\n        if (competidorAtual == c)\n            return false;\n            soma = pip[i];\n        }\n    }\n    return true;\n}\n</code></pre>\n<ul>\n<li>Em que isso ajuda? Intuitivamente é possível perceber que até um certo valor k (o tempo mínimo que almejamos) a equipe não conseguirá comer todas as pipocas, e a partir deste tempo ela sempre conseguirá.</li>\n<li>Se tentássemos representar esse comportamento em um vetor, teríamos algo assim:</li>\n</ul>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/e3549e7add92ad650fa708bc29b383da/7e11a/img9.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 10.429447852760736%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkklEQVR42h2Kuw6CQAAE+WMTTRQhxsrWQo2Cj8LSxtJeMT7ggsBxidoIBUaJ/zAeFJvJzq4xWCua45D2NKEzSzAdiVkzpTWJsRdKR2LPUyxX0nX1z7nRWyos7Sr2V4rGKGK4eWLsz3e2Ox8vyDiKnEB+8fwMkZYc/FfNahOp9kGOUCWXuKj7NXrr/6fOKSyQjx9/Q/B/VQ5wTQsAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img9' title='' src='/static/e3549e7add92ad650fa708bc29b383da/a6d36/img9.png' srcset='/static/e3549e7add92ad650fa708bc29b383da/222b7/img9.png 163w,\n/static/e3549e7add92ad650fa708bc29b383da/ff46a/img9.png 325w,\n/static/e3549e7add92ad650fa708bc29b383da/a6d36/img9.png 650w,\n/static/e3549e7add92ad650fa708bc29b383da/e548f/img9.png 975w,\n/static/e3549e7add92ad650fa708bc29b383da/7e11a/img9.png 1235w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li>Esse caráter monotônico, ou monótono, da função permite que apliquemos uma busca binária para encontrar o tempo k.</li>\n<li>Quando pensamos nos resultados da função compondo um vetor, é fácil ver que ela é não decrescente (f(x) &#x3C;= f(x+1)).</li>\n<li>Em suma, iremos aplicar uma busca binária com esq = 0 e dir = MAX, buscando o primeiro caso em que é possível comer todas as pipocas.</li>\n<li>Complexidade: O(n.log MAX)</li>\n</ul>\n<pre><code class=\"language-C++\">int solve(vector&#x3C;int> &#x26;pip, int c, int t_ini, int t_fim){\n    int x, k = t_fim;\n    while(t_ini &#x3C;= t_fim){\n        x = (t_ini + t_fim)/2;\n        if (ehPossivel(pip, c, x)){\n        k = x;\n        t_fim = x - 1;\n    } else {\n        t_ini = x + 1;\n        }\n    }\n    return k;\n}\n</code></pre>\n<ul>\n<li>\n<p>Como identificar se um problema pode ser resolvido por busca binária?</p>\n</li>\n<li>\n<p>É difícil determinar uma regra geral, além de que depende muito da modelagem e da forma que você está representando o problema.</p>\n</li>\n<li>\n<p>Mas uma dica importante é determinar se o problema possui um caráter monotônico como o exercício anterior.</p>\n</li>\n<li>\n<p>Pode ser descrito por uma função crescente ou decrescente.</p>\n</li>\n<li>\n<p>Exemplo de problema recorrente: determinar o menor x tal que f(x) >= k.</p>\n<ul>\n<li>Se vale que f(x) &#x3C;= f(x+1) para todo x, então o problema pode ser resolvido utilizando busca binária.</li>\n<li>Exemplo, com k = 20</li>\n</ul>\n</li>\n</ul>\n<p>img10.png</p>\n<h3>Método da bisseção</h3>\n<ul>\n<li>Até agora trabalhamos com funções no domínio dos inteiros.</li>\n<li>Esse problema pode ser generalizado para funções definida nos reais. Neste caso temos o chamado método da bisseção ou bissecção.</li>\n</ul>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 601px; '>\n      <a class='gatsby-resp-image-link' href='/static/c499748d32133acd1c9e67cc361cd8ae/d8f62/img11.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 92.63803680981594%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAABiklEQVR42q1U2W6DMBDk/7+uj32rVFQIp7mxjc3E44QUqhBQFUsbg/GOZ2fHCfDmEfCnKAoopd4HKITAOI5+YZ7nw6RXW4I4jpEmCaZpOsVgDZbXA0Q7btYDMhqGAVrr02VNxiIRHTqpn5fMcqcXgMuhlSgRX1Jcyg56svsayhOA1hh0/YjwImCM3dXyl+GOhkuO0gap08weNC1IXENe2aauK7RkljUw1h7bhpYhaF3X6LrOz2Tcti16957nBT4+vyDqxq0P6Pve68ngnqqqPJk8z9E0zb1kKSFdcAMPYMeVkihKgcyV+RPFaN3mm27Wa2qcpgRgdcxlDucgDENkWfawDcuiXoUD+k4r9z4/APYatr4MHjCKIg9oXXLsLEGzNoN8NODM7dnaxlElg8mFvDdnDUEHPDM+c+T9ym4Al6G18k1hMoNADGpFbQmw/sYGcf8uIM1N8ZmwgCzP7OatWWoTf+XYAHIDQTjzZD4vDGmT0xo+G2RDEILRn/8GXEogM5ZZluXm//II8Aoc+NhBw+H7HQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img11' title='' src='/static/c499748d32133acd1c9e67cc361cd8ae/d8f62/img11.png' srcset='/static/c499748d32133acd1c9e67cc361cd8ae/222b7/img11.png 163w,\n/static/c499748d32133acd1c9e67cc361cd8ae/ff46a/img11.png 325w,\n/static/c499748d32133acd1c9e67cc361cd8ae/d8f62/img11.png 601w' sizes='(max-width: 601px) 100vw, 601px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li>Exemplo: cálculo de raiz quadrada</li>\n</ul>\n<pre><code class=\"language-C++\">double raiz(double x, double eps=1e-3){\n    double l = 0, r = x;\n    double m;\n    while (r-l > eps){\n        m = (l+r)/2;\n        //cout &#x3C;&#x3C; m &#x3C;&#x3C; endl;\n    if (m*m &#x3C; x)\n        l = m;\n    else\n        r = m;\n    }\n    return (l+r)/2;\n}\n</code></pre>\n<ul>\n<li>Exemplo: cálculo de raiz quadrada</li>\n</ul>\n<pre><code class=\"language-C++\">sqrt(2) = 1.41421\n    1 1.5 1.25 1.375 1.4375 1.40625 1.42188 1.41406 1.41797\n    1.41602 1.41504 1.41455\nraiz(2) = 1.41455\n</code></pre>\n<h3>Função unimodal</h3>\n<ul>\n<li>Em alguns problemas também podemos lidar com funções unimodais.</li>\n<li>Funções que possuem apenas um ponto de mínimo ou máximo.</li>\n<li>Ou ainda, funções que apresentam apenas dois comportamentos: é crescente em um determinado intervalo e decrescente em outra.</li>\n<li>Neste caso é mais interessante aplicar uma busca ternária. Normalmente estamos procurando justamente o mínimo/máximo da função.</li>\n</ul>\n<p>Referências</p>\n<p><a href=\"http://www.ic.unicamp.br/~zanoni/mc102/2013-1s/aulas/aula15.pdf\">http://www.ic.unicamp.br/~zanoni/mc102/2013-1s/aulas/aula15.pdf</a></p>\n<p><a href=\"http://www.dcc.fc.up.pt/~pribeiro/aulas/daa1617/slides/2_ordenacao_07102016.pdf\">http://www.dcc.fc.up.pt/~pribeiro/aulas/daa1617/slides/2_ordenacao_07102016.pdf</a></p>\n<p><a href=\"https://www.ic.unicamp.br/~ripolito/peds/mc102z/material/aula13.pdf\">https://www.ic.unicamp.br/~ripolito/peds/mc102z/material/aula13.pdf</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=GU7DpgHINWQ\">https://www.youtube.com/watch?v=GU7DpgHINWQ</a></p>\n<p><a href=\"https://codeforces.com/blog/entry/76686\">https://codeforces.com/blog/entry/76686</a></p>\n<p><a href=\"https://sites.google.com/site/calcnum10/home/lista-2/metodos/metodo-da-bisseccao\">https://sites.google.com/site/calcnum10/home/lista-2/metodos/metodo-da-bisseccao</a></p>\n<p><a href=\"https://noic.com.br/materiais-informatica/curso/techniques-01/\">https://noic.com.br/materiais-informatica/curso/techniques-01/</a></p>"}},"pageContext":{"id":"ca95a3d6-a62b-5792-9aa0-3fed9b997aa1","frontmatter__slug":"busca-binaria","__params":{"frontmatter__slug":"busca-binaria"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}