{"componentChunkName":"component---src-pages-aprender-10-teoria-dos-numeros-markdown-remark-frontmatter-slug-tsx","path":"/aprender/10-teoria-dos-numeros/kmp-string-hashing/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"01 - Strings: KMP e String Hashing","description":"descricao","author":"Pedro Henrique Paiola, Rene Pegoraro, Wilson M Yonezawa, Arissa Yoshida, Nicolas Barbosa Gomes, Luis Henrique Morelli"},"html":"<h3>Strings em Programação Competitiva</h3>\n<ul>\n<li>Existem diversos problemas clássicos associados a Strings. Nesta aula trataremos sobre dois problemas específicos:</li>\n<li>Busca em Strings / String matching</li>\n<li>Substrings palindrômicas</li>\n</ul>\n<h3>Busca em strings</h3>\n<ul>\n<li>\n<p>O problema substring search/pattern search/string matching consiste em encontrar uma dada string dentro de outra.</p>\n</li>\n<li>\n<p>Exemplo:</p>\n<ul>\n<li>S = “Que a Força esteja com você”</li>\n<li>P = “Força”</li>\n</ul>\n</li>\n<li>\n<p>O problema substring search ou pattern search consiste em encontrar uma dada string dentro de outra.</p>\n</li>\n<li>\n<p>Exemplo:</p>\n<ul>\n<li>S = “Que a <strong>Força</strong> esteja com você”</li>\n<li>P = “Força”</li>\n</ul>\n</li>\n<li>\n<p>Ocorrências: 6 (posição)</p>\n</li>\n<li>\n<p>O problema substring search ou pattern search consiste em encontrar uma dada string dentro de outra.</p>\n</li>\n<li>\n<p>Exemplo:</p>\n<ul>\n<li>S = “<strong>aaba</strong>acaadaabaaba”</li>\n<li>S = “aabaacaad<strong>aaba</strong>aba”</li>\n<li>S = “aabaacaadaab<strong>aaba</strong>”</li>\n<li>P = “aaba”</li>\n</ul>\n</li>\n<li>\n<p>Ocorrências: 0, 9 e 12</p>\n</li>\n<li>\n<p>O problema substring search ou pattern search consiste em encontrar uma dada string dentro de outra.</p>\n</li>\n<li>\n<p>Exemplo:</p>\n<ul>\n<li>S = “aabaacaadaab<strong>aaba</strong>”</li>\n<li>P = “aaba”</li>\n</ul>\n</li>\n<li>\n<p>Ocorrências: 0, 9 e 12</p>\n</li>\n<li>\n<p>Algoritmo ingênuo</p>\n</li>\n</ul>\n<pre><code class=\"language-C++\">int search(string S, string P) {\n    int i, j;\n    for(i = 0; i &#x3C;= S.size() - P.size(); i++) {\n        for(j = 0; j &#x3C; P.size(); j++)\n            if (S[i+j] != P[j])\n                break;\n        if (j == P.size())\n            return i;\n    }\n    return -1;\n}\n</code></pre>\n<ul>\n<li>Esse algoritmo, no pior caso, tem complexidade 𝑂(𝑚. 𝑛), fazendo 𝑚. 𝑛 comparações. Porém, em geral, ele não chega a realizar tantas comparações.</li>\n<li>Usar esse algoritmo é bastante razoável para vários casos, principalmente quando as strings não são muito grandes.</li>\n<li>Mas, existem algoritmos de busca de substrings mais eficientes, que podem ser necessários em algumas situações, como exemplo temos o KMP</li>\n</ul>\n<h3>Alguns conceitos</h3>\n<ul>\n<li>Prefixo de uma string S é a string obtida após a remoção de 0 ou mais caracteres do fim de S.</li>\n<li>“a”, “adc”, “adcbaa” são prefixos de “adcbaa”</li>\n<li>Sufixo de uma string S é a string obtida após a remoção de 0 ou mais carateres do início de S.</li>\n<li>“a”, “baa”, “adcbaa” são sufixos de “adcbaa”</li>\n<li>Prefixo/sufixo próprio de S é um prefixo/sufixo de S que é diferente de S.</li>\n<li>Substring de uma string S é uma string obtida após a remoção de 0 ou mais caracteres no início ou no fim de S.</li>\n<li>“a”, “cba”, “adc”, “dcba”, “adcbaa” são substrings de “adcbaa”</li>\n</ul>\n<h3>KMP</h3>\n<ul>\n<li>\n<p>Knuth Morrit Pratt</p>\n</li>\n<li>\n<p>Complexidade: 𝑂(𝑛 + 𝑚) no pior caso</p>\n</li>\n<li>\n<p>No algoritmo ingênuo, sempre que detectamos caracteres diferentes, avançávamos um caracter na string principal (i++) e testamos toda a substring, desde o começo (começando sempre com j = 0).</p>\n</li>\n<li>\n<p>O KMP, porém, aproveita as comparações que foram feitas antes de encontrar dois caracteres diferentes, evitando comparar novamente caracteres que já sabemos que são compatíveis.</p>\n</li>\n<li>\n<p>A principal ideia deste algoritmo é pré-processar o padrão P, de modo a obter um vetor de inteiros lps, que conta o número de caracteres que podem ser “ignorados” em uma nova comparação.</p>\n</li>\n<li>\n<p>O nome lps refere-se à “longest proper prefix and suffix”, ou seja, o maior prefixo próprio (não pode ser a própria palavra) que também é sufixo.</p>\n</li>\n<li>\n<p>Conhecido também como função de prefixo.</p>\n</li>\n<li>\n<p>Confira a GIF abaixo:</p>\n</li>\n</ul>\n<p><img src=\"/static/gif1-20eb39bb98c5b5bdf764f4eca504545d.gif\" alt=\"img1-img11\"></p>\n<pre><code class=\"language-C++\">int a[MAX], n, m;\nchar S[MAX], P[MAX];\nvoid calculatePrefix(){\n    int i = 0, j = -1;\n    a[0] = -1;\n    while(i &#x3C; m){\n        while(j >= 0 &#x26;&#x26; P[i] != P[j])\n            j = a[j];\n        i++; j++;\n        a[i] = j;\n    }\n}\n\nvector&#x3C;int> KMP2(){ //retorna todas as ocorrências da substring\n    vector&#x3C;int> resp;\n    int i = 0, j = 0;\n    calculatePrefix();\n    while(i &#x3C; n){\n        while(j >= 0 &#x26;&#x26; S[i] != P[j])\n            j = a[j];\n        i++; j++;\n        if (j == m){\n            resp.push_back(i - m);\n            j = a[j];\n        }\n    }\n    return resp;\n}\n</code></pre>\n<ul>\n<li>Sugestão para entender mais sobre o KMP e suas aplicações:\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=RXISWaGmYW8\">Algoritmo de KMP | Vídeo do Bruno Monteiro</a></li>\n</ul>\n</li>\n</ul>\n<h3>String Hashing</h3>\n<ul>\n<li>Uma técnica bastante interessante e relativamente simples de se utilizar é a de String Hashing.</li>\n<li>Primeiramente, vamos revisar, de forma muito intuitiva, o conceito de Hashing.</li>\n</ul>\n<h3>Hashing</h3>\n<ul>\n<li>Podemos pensar em uma problema de busca da seguinte forma:</li>\n<li>Considere um conjunto de chaves 𝐾 e um conjunto de valores 𝑉, de forma que cada chave 𝑘 está associada a um único valor 𝑣 (𝑚𝑎𝑝[𝑘] = 𝑣).</li>\n<li>Dado um valor 𝑐 qualquer, encontrar a chave 𝑘 a qual ele está associado (pensando em um vetor, encontrar a posição em que ele se encontra)</li>\n<li>O Hashing (tabela de dispersão) consiste em um método de cálculo de endereço (de chave) a partir do valor, de forma que, no caso médio, a chave pode ser encontrada em tempo constante.</li>\n<li>Exemplo: encontrar a posição em que um certo nome está armazenado.</li>\n<li>Complexidade:</li>\n<li>𝑂(𝑛), se o vetor não estiver ordenado</li>\n<li>𝑂(log 𝑛), usando busca binária em vetor ordenado</li>\n</ul>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/3a8d599ab64bbe795d2ad110b8ce8d95/3f8cf/img12.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 12.269938650306749%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAk0lEQVR42iXK3wrBYACG8V0PmSXNgUtwmxIhIYeK0mz7tlbjQKv5E2bKiRw4MN+zr+3s/T29Wua3+QkThAFulb9TQXqNYkuhI/0WqFZ2U7VaaddQbha/zKkr6xB20N7xiv26SxLOyRKLsxhxdIeQ2nziJSdvDE+bdLcgsvpcgynyYRFtB9yCGbwEF3/CYdPje3fIASYLgI/r7L2LAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img12' title='' src='/static/3a8d599ab64bbe795d2ad110b8ce8d95/a6d36/img12.png' srcset='/static/3a8d599ab64bbe795d2ad110b8ce8d95/222b7/img12.png 163w,\n/static/3a8d599ab64bbe795d2ad110b8ce8d95/ff46a/img12.png 325w,\n/static/3a8d599ab64bbe795d2ad110b8ce8d95/a6d36/img12.png 650w,\n/static/3a8d599ab64bbe795d2ad110b8ce8d95/e548f/img12.png 975w,\n/static/3a8d599ab64bbe795d2ad110b8ce8d95/3f8cf/img12.png 1293w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li>Agora, suponha que tivéssemos uma “função mágica” que, dado um nome, calcule em tempo constante exatamente a posição que ele deveria ocupar nesse vetor.</li>\n<li>Essa é a ideia da função hash. Claro que na prática isto não é tão simples, mas o nosso foco aqui é mais específico.</li>\n</ul>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/00e05414414a69d5b24a95b394b0c590/d4377/img13.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 12.269938650306749%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkElEQVR42h3J7Q6BYABA4e6yLVsm888NuDyzktD62kqNGHu1lSTNGDqsf+fZkR7umPNU4W6pfH2Nqy5TGj0IhrycAZWpdV0vFApd5WYqtIFGPpOprT6EIy660vkdTZCa7EBiG4jY51MKjqHD1l3SXjMasWMfrKHKKNKIxDH/3+2ceitOkQNNjth4xPacZyH4ARKshugrYJawAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img13' title='' src='/static/00e05414414a69d5b24a95b394b0c590/a6d36/img13.png' srcset='/static/00e05414414a69d5b24a95b394b0c590/222b7/img13.png 163w,\n/static/00e05414414a69d5b24a95b394b0c590/ff46a/img13.png 325w,\n/static/00e05414414a69d5b24a95b394b0c590/a6d36/img13.png 650w,\n/static/00e05414414a69d5b24a95b394b0c590/e548f/img13.png 975w,\n/static/00e05414414a69d5b24a95b394b0c590/d4377/img13.png 1294w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li>De forma muito simplista, uma função hash nos gera um número que identifica um dado qualquer (outro número, uma string, uma struct...)</li>\n<li>Idealmente, identifica unicamente, de forma que cada chave está associada a apenas um valor. Na prática, podemos ter problema de colisões.</li>\n<li>E o que isto nos ajuda com strings?</li>\n<li>Comparar duas substrings tem complexidade 𝑂(𝑛), sendo n o número de caracteres.</li>\n<li>Mas, se calcularmos um hash dessas substrings, obteremos seus “números de identificação”, que podem ser comparados em 𝑂(1).</li>\n</ul>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/ff84e81e309c7621dbcebd1b94f8f318/2bef9/img14.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.44171779141104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABfElEQVR42p1SbU7CQBDlLF7EP17EM3gGEs9APIMIxOgPg78FozEm1RDaqCkt/YK2tLZ0P56zWzFogBAneensdObN251ptNttWJYJZYwzcMbAGAfnHEII/d0JypdU+2L7uH820FBE6dzG9P0RLiFwDNjWABPrDvki0I2kFKhNYptJKXWDxqpAkDpW5eRz7VdVSUqrOpmUyqrAPtZYP8yiGRzHxbKk4sqFyMakKUV+e4bo9AjVxwMkm4KrOIsxn8c/TTcTziJMJg4+8wwoTPCECGSAvN9C1DwkwiHkkuLpEykOkWaFfvethLveR/4p1Ob7NMl/EG61KAJNYjOhWpEkSTSqZUmdY4jSoz8cxfAccesYzBuR3BSy9GlQJeJFpif7i1BNlehIeQnTHMEwDEShS7s0BPNvIJiNtNtEcHKA4vUaYjEAD/vUzIXn+bQNha5XPAr7XVmpUIPaZ21Cs4sVgnEHPiEwO3S++Ab5Vg/h21Xtr8XrPFXbQ2Rdav8LWSZL2wGUOj8AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img14' title='' src='/static/ff84e81e309c7621dbcebd1b94f8f318/a6d36/img14.png' srcset='/static/ff84e81e309c7621dbcebd1b94f8f318/222b7/img14.png 163w,\n/static/ff84e81e309c7621dbcebd1b94f8f318/ff46a/img14.png 325w,\n/static/ff84e81e309c7621dbcebd1b94f8f318/a6d36/img14.png 650w,\n/static/ff84e81e309c7621dbcebd1b94f8f318/e548f/img14.png 975w,\n/static/ff84e81e309c7621dbcebd1b94f8f318/2bef9/img14.png 1024w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li>Na prática:\n<ul>\n<li>Dada a(s) string(s) de entrada, realizaremos um pré-processamento para o cálculo do hash (𝑂(𝑛)).</li>\n<li>A partir deste pré-processamento, podemos obter o hash de qualquer substring em 𝑂(1).</li>\n<li>Com isso, a resolução de uma série de problemas terá uma grande queda de complexidade, comparada com a solução por força bruta.</li>\n<li>Para calcular o hash de uma string qualquer, utilizaremos a técnica de polynomial rolling. De forma que, dada uma string 𝑠 , o ℎ𝑎𝑠ℎ(𝑠) é calculado da seguinte forma:</li>\n</ul>\n</li>\n</ul>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/75a788ada1e123a1da3454a251e1cd70/bb3b7/img15.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 16.56441717791411%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAbUlEQVR42o2NOQ4EIRAD+f8rCQgR943AK7d2sgnGkkVj3IWy1sJ7jzEGnHMopWCthZwzYozovWPvjTknUkpy51lrlU5rTTJ2matzDigCjTGyyAJNMHPO7NH33lc/bwp/cUlrLb8+AAJDCAL9qh+iBOpnhvR8OQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img15' title='' src='/static/75a788ada1e123a1da3454a251e1cd70/a6d36/img15.png' srcset='/static/75a788ada1e123a1da3454a251e1cd70/222b7/img15.png 163w,\n/static/75a788ada1e123a1da3454a251e1cd70/ff46a/img15.png 325w,\n/static/75a788ada1e123a1da3454a251e1cd70/a6d36/img15.png 650w,\n/static/75a788ada1e123a1da3454a251e1cd70/e548f/img15.png 975w,\n/static/75a788ada1e123a1da3454a251e1cd70/bb3b7/img15.png 1211w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li>\n<p>em que 𝑃 é um número primo muito grande e 𝑏 uma constante aleatória (normalmente um primo de valor próximo ao tamanho do alfabeto)</p>\n</li>\n<li>\n<p>A ideia é evitar colisões, mas não entraremos a fundo na fundamentação probabilística deste problema.</p>\n</li>\n<li>\n<p>Exemplo: seja 𝑠 = “𝐴𝐿𝐿𝐸𝑌”, b = 3 e P = 97:</p>\n</li>\n</ul>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/5439692a1f394bece718b115854e092a/c9c3a/img16.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 11.042944785276074%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAg0lEQVR42i2KwQqCQBRF/aYISukbqnV/2ibETdgMZFMUgbiKRDGjVpGTpzdTiwvn3nODziywuxns56DHfJRET4RH9BKrQlBD7xy7Db9H8o3+vxCbDsBMCcpTTJsncDPQbHkWCY/C9Yyu3NCcV/S19s7x+5p6d8/j36/NeF3WVMel8IEvPbaFBtNjmnYAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img16' title='' src='/static/5439692a1f394bece718b115854e092a/a6d36/img16.png' srcset='/static/5439692a1f394bece718b115854e092a/222b7/img16.png 163w,\n/static/5439692a1f394bece718b115854e092a/ff46a/img16.png 325w,\n/static/5439692a1f394bece718b115854e092a/a6d36/img16.png 650w,\n/static/5439692a1f394bece718b115854e092a/e548f/img16.png 975w,\n/static/5439692a1f394bece718b115854e092a/c9c3a/img16.png 1289w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>(65 × 3^4 + 76 × 3^3 + 76 × 3^2 + 69 × 3^1 + 89 ∗ 3^0) 𝑚𝑜𝑑 97 = 52\nℎ𝑎𝑠ℎ(\"ALLEY\") = 52</p>\n<h3>Pré-processamento</h3>\n<ul>\n<li>Durante o pré-processamento de nossa substring, construiremos dois vetores que serão importantes para o cálculo do hash de qualquer substring:</li>\n</ul>\n<pre><code>ℎ[𝑖] = armazena o hash do prefixo s[0...i]\nℎ[0] = 𝑠[0]\nℎ[𝑖] = (ℎ[𝑖 − 1] ∗ 𝑏 + 𝑠[𝑖]) 𝑚𝑜𝑑 𝑃\n𝑝[𝑖] = armazena o coeficiente polinomial 𝑏𝑖 𝑚𝑜𝑑 𝑃\n𝑝[0] = 1\n𝑝[𝑖] = (𝑝[𝑖 − 1] ∗ 𝑏) 𝑚𝑜𝑑 𝑃\n</code></pre>\n<ul>\n<li>Confira a GIF abaixo:</li>\n</ul>\n<p><img src=\"/static/gif2-633011eee0bb7e54f0cdc34b3dd3ac8f.gif\" alt=\"img17-img29\"></p>\n<ul>\n<li>A partir das estruturas criadas no pré-processamento podemos obter o hash de qualquer substring em tempo constante.</li>\n<li>Por exemplo, suponha que queremos o hash de “LLE” da substring anterior, dado por ℎ𝑎𝑠ℎ “𝐿𝐿𝐸” = 𝐿. 𝑏2 + 𝐿. 𝑏 + 𝐸.</li>\n<li>Nós já temos calculados os seguintes hashs:\n<pre><code>ℎ 3 = ℎ𝑎𝑠ℎ “𝐴𝐿𝐿𝐸” = 𝐴. 𝑏3 + 𝐿. 𝑏2 + 𝐿. 𝑏 + 𝐸\nℎ 0 = ℎ𝑎𝑠ℎ “𝐴” = 𝐴\n</code></pre>\n</li>\n<li>A partir destes podemos fazer a seguinte operação:</li>\n<li>ℎ𝑎𝑠ℎ(\"LLE\") = hash(\"ALLE\") − hash(\"A\").𝑏3 = 𝐴. 𝑏3 + 𝐿. 𝑏2 + 𝐿. 𝑏 + 𝐸 − 𝐴.𝑏3</li>\n</ul>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/8a32f22aeaf4390beed4124dc93dc250/2bef9/img30.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.44171779141104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB0klEQVR42o1SXW/TMBTtL+SZN1555+/wOmASUoGJv8Am2LR2aZnWrel3EuejdZImthvbB9vpoAVVwtKRj+17j499b6fb7cIfP8EOKaWDUtrAcvV77ySaBtrk3i9jXHs/0bFCxYYgWo4QB48gwZPhDwgt5gMEkx9gFXUXaq1xatgze4ETBF9A0m+QpWfQh8yvzfoKDSPGgTTBEv87nKCcv4W+fYHd8A3k4DVE7xXU3Uvo/LsLErxGXdfgXIAz1nLxzJn7miPBKgsg0gnicQ/bcIR0OgRPfChRuyBCCIIgQBzHiKLIzARJkiA0e1EYYrfbHQuy9RwN8bCZ3oCFHujsBtXqFloUrUPBjTuOim2RVxtsWYGaV84lMy61+sthSXyIsI/o4RLlogcyukQ6voLiuQsqigKUUuQFRUYT0GKNvKQoy9Lt22IcCSpeQG0JeB5C7mdBV9ANhy3sc3VtKwnJ0agdlCvUv1Xv2ApqbfpNtVAH9tuEA+yFbXybZ6DkH673bZOuc8yWCfxZhMVqbZ7EkGQl1rQ2T+OOZ7Ry69RwqU73YyfzLxDcf8RieI6Z9wGLwbnjk94ZJv2zlvffYXb33p1PDY8fP5k//nKAC2T+VzN/xi992EYV4pD57AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img30' title='' src='/static/8a32f22aeaf4390beed4124dc93dc250/a6d36/img30.png' srcset='/static/8a32f22aeaf4390beed4124dc93dc250/222b7/img30.png 163w,\n/static/8a32f22aeaf4390beed4124dc93dc250/ff46a/img30.png 325w,\n/static/8a32f22aeaf4390beed4124dc93dc250/a6d36/img30.png 650w,\n/static/8a32f22aeaf4390beed4124dc93dc250/e548f/img30.png 975w,\n/static/8a32f22aeaf4390beed4124dc93dc250/2bef9/img30.png 1024w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h3>Hash de substring</h3>\n<ul>\n<li>A partir das estruturas criadas no pré-processamento podemos obter o hash de qualquer substring em tempo constante.</li>\n<li>Generalizando:</li>\n</ul>\n<pre><code>ℎ𝑎𝑠ℎ 𝑆 [𝑙 … 𝑟] = (ℎ [𝑟] − ℎ [𝑙 − 1] ∗ 𝑝 [𝑟 − 𝑙 + 1] ) 𝑚𝑜𝑑 𝑃\n</code></pre>\n<h3>Complexidade do String Hashing</h3>\n<ul>\n<li>Pré-processamento: 𝑂(𝑛)</li>\n<li>Consulta: 𝑂(1)</li>\n</ul>\n<h3>Implementação</h3>\n<pre><code class=\"language-C++\">mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());\nconst ll P = 1e18+9;\nconst ll b = uniform_int_distribution&#x3C;ll>(0, P-1)(rng);\ninline ll mult(ll a, ll b, ll mod){\n    return (a*b-(ll)((long double)a/mod*b)*mod + mod)%mod;\n}\n\nstruct hash_str\n{\n    vector&#x3C;ll> h, p;\n    hash_str(string s) : h(s.size()), p(s.size()) {\n        int n = s.size();\n        h[0] = s[0] + 128;\n        p[0] = 1;\n        for(int i = 1; i &#x3C; n; i++){\n            h[i] = (mult(h[i-1],b,P) + s[i] + 128) % P;\n            p[i] = mult(p[i-1],b,P);\n        }\n    }\n\n    ll sub_hash(int l, int r){\n        if (l == 0)\n            return h[r];\n        ll ans = (h[r] - mult(h[l-1], p[r-l+1],P)) % P;\n        if (ans &#x3C; 0)\n            ans += P;\n        return ans;\n    }\n};\n</code></pre>\n<h3>Busca em strings com String Hashing</h3>\n<ul>\n<li>Dada uma string 𝑆, de tamanho 𝑛, como determinados se a string 𝑃, de tamanho 𝑚, está presente em 𝑆?</li>\n<li>Calculamos o hash das duas strings, e então comparamos 𝑃 com todas as substrings de tamanho 𝑚 de 𝑆. A ideia é semelhante a força bruta, porém se torna eficiente devido ao uso do hashing.</li>\n<li>Algoritmo de Rabin-Karp</li>\n</ul>\n<pre><code class=\"language-C++\">hash_str hs(s), hp(p);\nint ans = 0;\nvector&#x3C;int> pos;\nint n = s.size(), m = p.size();\nfor(int i = 0; i &#x3C;= n-m; i++){\n    if (hs.sub_hash(i, i+m-1) == hp.sub_hash(0, m-1))\n    {\n        ans++;\n        pos.push_back(i);\n    }\n}\n</code></pre>\n<ul>\n<li>Complexidades:</li>\n<li>Força bruta: 𝑂(𝑛. 𝑚)</li>\n<li>KMP: 𝑂(𝑛 + 𝑚)</li>\n<li>String Hashing:</li>\n<li>Pré-processamento: 𝑂(𝑛 + 𝑚)</li>\n<li>Consulta: 𝑂(𝑛 − 𝑚)</li>\n</ul>\n<h3>Exemplos de outros problemas</h3>\n<ul>\n<li>Determinar a maior substring de 𝑃 que ocorre em 𝑆</li>\n<li>Busca binária no tamanho da substring. Procura todas as substrings de tamanho 𝑥 de 𝑃 em 𝑆.</li>\n<li>𝑂(𝑛²log 𝑛)</li>\n<li>Determinar a quantidade de diferentes substrings de S.</li>\n<li>Para cada possível tamanho de substring cria um set e o povoe com o hash de todas as substrings possíveis. Somando o tamanho dos sets teremos a quantidade de diferentes substrings de 𝑆.</li>\n<li>𝑂(𝑛²log 𝑛)</li>\n<li>Determinar a maior substring palindrômica de S.</li>\n<li>Backward hash: calcular o hash para a string invertida também.</li>\n<li>𝑂(𝑛²)</li>\n<li>Utilizando algoritmo de Manacher (sem String Hashing): 𝑂(𝑛)</li>\n</ul>\n<h3>Cuidados</h3>\n<ul>\n<li>O maior problema da técnica de String Hashing é a possibilidade da ocorrência de colisões: quando duas strings diferentes resultam no mesmo hash.</li>\n<li>Formas de diminuir a probabilidade de ocorrência:</li>\n<li>Utilização de valores adequados para os parâmetros 𝑏 e 𝑃.</li>\n<li>Duplo hashing.</li>\n</ul>\n<h3>Outras técnicas para lidar com Strings</h3>\n<ul>\n<li>Existem diversas outras técnicas e estruturas que ajudam a lidar com problemas de Strings, por exemplo:</li>\n<li>Para lidar com palíndromos:\n<ul>\n<li>Algoritmo de Manacher</li>\n<li>Palindromic Tree</li>\n<li>Z-function</li>\n<li>String matching utilizando autômato finito</li>\n<li>Algoritmo de Aho-Corasick</li>\n<li>Trie</li>\n<li>Suffix Array</li>\n<li>Suffix Tree</li>\n<li>Autômato de Sufixos</li>\n<li>Fatorização de Lyndon / Algoritmo de Duval</li>\n</ul>\n</li>\n</ul>\n<h3>Referências</h3>\n<p>S. Halim e F. Halim. Competitive Programming 2.</p>\n<p>Fábio L. Usberti. Processamento de Cadeias de Caracteres. Summer School 2019.</p>\n<p>Rafael Grandsire. String Hashing. Summer School 2022.</p>\n<p><a href=\"https://www.youtube.com/watch?v=RXISWaGmYW8\">https://www.youtube.com/watch?v=RXISWaGmYW8</a></p>\n<p><a href=\"https://cp-algorithms-brasil.com/strings/prefixo.html\">https://cp-algorithms-brasil.com/strings/prefixo.html</a></p>\n<p><a href=\"https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/\">https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/</a></p>\n<p><a href=\"https://www.ime.usp.br/~pf/estruturas-de-dados/aulas/kmp.html\">https://www.ime.usp.br/~pf/estruturas-de-dados/aulas/kmp.html</a></p>\n<p><a href=\"http://www2.ic.uff.br/~boeres/slides_ed/ed_TabelaHash.pdf\">http://www2.ic.uff.br/~boeres/slides_ed/ed_TabelaHash.pdf</a></p>\n<p><a href=\"https://usaco.guide/CPH.pdf\">https://usaco.guide/CPH.pdf</a></p>\n<p><a href=\"https://cp-algorithms.com/string/string-hashing.html\">https://cp-algorithms.com/string/string-hashing.html</a></p>\n<p><a href=\"https://www.geeksforgeeks.org/string-hashing-using-polynomial-rolling-hash-function/\">https://www.geeksforgeeks.org/string-hashing-using-polynomial-rolling-hash-function/</a></p>\n<p><a href=\"https://usaco.guide/gold/string-hashing?lang=cpp\">https://usaco.guide/gold/string-hashing?lang=cpp</a></p>"}},"pageContext":{"id":"ad88c71b-e7e5-5eab-b7ce-ad219caa978a","frontmatter__slug":"kmp-string-hashing","__params":{"frontmatter__slug":"kmp-string-hashing"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}