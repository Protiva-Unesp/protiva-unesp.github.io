{"componentChunkName":"component---src-pages-aprender-08-arvores-markdown-remark-frontmatter-slug-tsx","path":"/aprender/08-arvores/disjoint-set-union/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Disjoint-set (Union-find)","description":"descricao","author":"Pedro Henrique Paiola, Rene Pegoraro, Wilson M Yonezawa, Toki Yoshida, Nick Papi Barbosa Gomes, Pseudo-Pedro Henrique Morelli"},"html":"<h2>IntroduÃ§Ã£o</h2>\n<p>â— Disjoint Set Union (DSU), tambÃ©m chamada de Union-find, devido as\noperaÃ§Ãµes que esta estrutura de dados permite\nâ— Esta estrutura armazena vÃ¡rios conjuntos disjuntos de elementos\nâ—‹ Inicialmente, cada conjunto contÃ©m precisamente um elemento\nâ— Permite a realizaÃ§Ã£o de duas operaÃ§Ãµes:\nâ—‹ merge(a, b): une os conjuntos aos quais a e b pertencem.\nâ—‹ find(a): determina a qual conjunto o elemento a pertence.\nâ— A partir do find, normalmente define-se a funÃ§Ã£o same:\nâ—‹ same(a, b): determina se a e b pertencem ao mesmo conjunto.</p>\n<p>img1 - img5 (montar gif)\n<img src=\"/static/gif1-cadfc3592eda96b912bb46b202e5062c.gif\" alt=\"gif1\"></p>\n<h3>Estruturando a soluÃ§Ã£o</h3>\n<p>â— Para implementar uma DSU, cada conjunto serÃ¡ representado por uma\nÃ¡rvore, onde a raiz da Ã¡rvore serÃ¡ o representante/lÃ­der do conjunto.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/8992ab49fb275f3d2029073b8395e0cc/2bef9/img7.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.44171779141104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABMElEQVR42p1S7U6DQBDk/V+kakwTTXwJNVFLsT+slFikpUAwR/k67m5clp5pjDVtN5nM3u4x+3E44/EYi4WP3qSU6LqOoZSForNkqF2cfaU518cMfTsLN3h0X+Fo1WKzchEtH4gnSNZTJLGHdfSEPPMRr17wlQecy9M54uiZ7t4jS99IsIU1YwwXcMjlRC+slNxDH+sG1op8yehkRR3WnCMV/DbHOk3b8hjWOh5V4VRzbLuiKNDSDq2VZQkhxHmCdV3zg1TEvbikRfe+jZ8sWIiCx62oK0X7qqsKTdMORcg/o8OGFq9/XsvsLdv8sfj/BY3Cdivof6LRjD4IQ/eOgcP1je1sYE2sDXbnwT+6w9C7xOfsGkvij+mA0LtCMLkgjPgcuCMk8xuk77cHkfl3zN/ok1aawFBOhgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img7' title='' src='/static/8992ab49fb275f3d2029073b8395e0cc/a6d36/img7.png' srcset='/static/8992ab49fb275f3d2029073b8395e0cc/222b7/img7.png 163w,\n/static/8992ab49fb275f3d2029073b8395e0cc/ff46a/img7.png 325w,\n/static/8992ab49fb275f3d2029073b8395e0cc/a6d36/img7.png 650w,\n/static/8992ab49fb275f3d2029073b8395e0cc/e548f/img7.png 975w,\n/static/8992ab49fb275f3d2029073b8395e0cc/2bef9/img7.png 1024w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h3>ImplementaÃ§Ã£o (nem tÃ£o) ingÃªnua</h3>\n<p>â— find(x): retorna o lÃ­der do conjunto a que x pertence\nâ— merge(x, y): conecta os lÃ­deres. Supondo que X seja lÃ­der de x e Y lÃ­der de\ny, vamos â€œelegerâ€ Y como lÃ­der de X.</p>\n<pre><code class=\"language-C++\">int pai[MAX_N + 1];\nvoid init(){\n    for(int i = 1; i &#x3C;= MAX_N; i++)\n        pai[i] = i;\n}\nint find(int x){\n    if (pai[x] == x)\n        return x;\n    return find(pai[x]);\n}\nbool same(int x, int y){\n    return find(x) == find(y);\n}\nvoid merge(int u, int v){\n    int a = find(u);\n    int b = find(v);\n    pai[a] = b;\n}\n</code></pre>\n<p>img7 - img9 (montar gif)\n<img src=\"/static/gif2-e74d9329cfe7540063feef033fad8592.gif\" alt=\"gif2\"></p>\n<p>img10 - img14\n![gif3](gif3.gif]</p>\n<h3>Path Compression</h3>\n<p>â— Ideia: comprimir os caminhos, fazendo todos os elementos do conjunto\napontarem para o lÃ­der diretamente.\nâ— Uma espÃ©cie de ProgramaÃ§Ã£o DinÃ¢mica.\nâ— Tempo por operaÃ§Ã£o: ğ‘‚(log ğ‘›) amortizado</p>\n<pre><code class=\"language-C++\">int pai[MAX_N + 1];\nvoid init(){\n    for(int i = 1; i &#x3C;= MAX_N; i++)\n        pai[i] = i;\n}\nint find(int x){\n    if (pai[x] == x)\n    return x;\n    return pai[x] = find(pai[x]);\n}\nvoid merge(int u, int v){\n    int a = find(u);\n    int b = find(v);\n    pai[a] = b;\n}\n</code></pre>\n<p>img15 - img23\n<img src=\"/static/gif4-4242e5fc87429bbd17d98bb20a288224.gif\" alt=\"gif4\"></p>\n<h3>Union by size</h3>\n<p>â— Ideia: unir os conjuntos do menor para o maior, minimizando a\nprofundidade dos conjuntos.\nâ— EstratÃ©gia â€œsmall-to-largeâ€\nâ— Tempo por operaÃ§Ã£o: O(log n)</p>\n<pre><code class=\"language-C++\">int pai[MAX_N + 1];\nint tam[MAX_N + 1];\n\nvoid init()\n{\n    for(int i = 1; i &#x3C;= MAX_N; i++)\n    {\n        pai[i] = i;\n        tam[i] = 1;\n    }\n}\n\nint find(int x)\n{\n    if (pai[x] == x)\n        return x;\n    return find(pai[x]);\n}\nvoid merge(int u, int v)\n{\n    int a = find(u);\n    int b = find(v);\n    if (tam[a] > tam[b])\n        swap(a,b);\n    pai[a] = b;\n    tam[b] += tam[a];\n}\n</code></pre>\n<p>img24 - img28 (montar gif)\n<img src=\"/static/gif5-183c75fb2f424e5890304abd49b1c8e9.gif\" alt=\"gif5\"></p>\n<h3>Path Compression + Union by size</h3>\n<p>â— Unindo ambas as tÃ©cnicas garante-se complexidade quase constante, sendo\na implementaÃ§Ã£o mais recomendada.\nâ— Outras tÃ©cnicas de melhorias (na uniÃ£o dos conjuntos)\nâ—‹ Union by rank\nâ—‹ Linking by index\nâ—‹ Coin-flip linking</p>\n<h3>Problema: WAR (UVa - 10158)</h3>\n<p>â— Conjunto n de pessoas de diferentes paÃ­ses.\nâ— Duas pessoas sÃ£o consideradas amigas se sÃ£o do mesmo paÃ­s, ou inimigas se\nsÃ£o diferentes paÃ­ses.\nâ— Neste problema, podem ser feitas 4 tipos de operaÃ§Ãµes:\nâ—‹ setFriends(x, y)\nâ—‹ setEnemies(x, y)\nâ—‹ areFriends(x, y)\nâ—‹ areEnemies(x,y)\nâ— Se uma operaÃ§Ã£o contradizer alguma anterior, ela nÃ£o Ã© realizada e\nimprimimos -1 na tela</p>\n<p>â— Propriedades da amizade ~:\nâ—‹ Se ğ‘¥ ~ ğ‘¦ e ğ‘¦ ~ ğ‘§, entÃ£o ğ‘¥ ~ ğ‘§\nâ—‹ Se ğ‘¥ ~ ğ‘¦ entÃ£o ğ‘¦ ~ ğ‘¥\nâ—‹ ğ‘¥ ~ ğ‘¥</p>\n<p>â— Propriedades da inimizade âˆ—:\nâ—‹ Se ğ‘¥ âˆ— ğ‘¦ entÃ£o ğ‘¦ âˆ— ğ‘¥\nâ—‹ NÃ£o acontece ğ‘¥ âˆ— ğ‘¥</p>\n<p>â— E tambÃ©m\nâ—‹ Se ğ‘¥ âˆ— ğ‘¦ e ğ‘¦ âˆ— ğ‘§, entÃ£o ğ‘¥ ~ ğ‘§ (o inimigo do meu inimigo Ã© meu amigo)\nâ—‹ Se ğ‘¥ ~ ğ‘¦ e ğ‘¦ âˆ— ğ‘§, entÃ£o ğ‘¥ âˆ— ğ‘§ (o inimigo do meu amigo Ã© meu inimigo)</p>\n<p>â— A partir dessas propriedades, podemos modelar o problema utilizando\ndisjoint-sets. Cada pessoa ğ‘¥ possui dois conjuntos associados, o conjunto\nğ‘ğ‘šğ‘–ğ‘”ğ‘œğ‘ (ğ‘¥) e o conjunto ğ‘–ğ‘›ğ‘–ğ‘šğ‘–ğ‘”ğ‘œğ‘ (ğ‘¥). E estes conjuntos devem satisfazer as\npropriedades anteriores.</p>\n<p>â— Detalhe de implementaÃ§Ã£o: nos exemplos que vimos atÃ© agora, criamos um\nvetor ğ‘ğ‘ğ‘– de tamanho N, de forma que cada elemento comeÃ§a associado a\num conjunto. Neste exercÃ­cio vamos criar um vetor de tamanho 2*N, onde a\nprimeira metade sÃ£o os conjuntos de amigos e a segunda de inimigos</p>\n<p>â— Inicializando os conjuntos:\nâ—‹ Toda pessoa Ã© amiga dela mesma (ğ‘¥ ~ ğ‘¥)\nâ–  pai[amigos(x)] = x;\nâ—‹ NinguÃ©m Ã© inimigo de si mesmo (NÃ£o ğ‘¥ âˆ— ğ‘¥)\nâ–  pai[inimigos(x)] = 0; //Considerando as pessoas numeradas de 1 a n</p>\n<p>â— setFriends(x, y)\nâ—‹ Primeiro, precisamos verificar se x e y nÃ£o sÃ£o inimigos, o que iria\ngerar uma contradiÃ§Ã£o\nâ—‹ Caso nÃ£o, entÃ£o fazemos\nâ–  merge(amigos(x), amigos(y))\nâ–  merge(inimigos(x), inimigos(y))</p>\n<p>â— setEnemies(x, y)\nâ—‹ Primeiro, precisamos verificar se x e y nÃ£o sÃ£o amigos, o que iria gerar\numa contradiÃ§Ã£o\nâ—‹ Caso nÃ£o, entÃ£o fazemos\nâ–  merge(amigos(x), inimigos(y))\nâ–  merge(inimigos(x), amigos(y))</p>\n<p>â— areFriends(x, y)\nâ—‹ same(amigos(x), amigos(y))\nâ— areEnemies(x, y)\nâ—‹ same(amigos(x), inimigos(y))</p>\n<p>Rollback\nâ— Em alguns problemas, pode ser necessÃ¡rio realizar um rollback, desfazendo\nuniÃµes imediatamente anteriores.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/01a41af820e7d2cd5a5323be665fdc28/6bfd0/img29.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 37.423312883435585%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABCklEQVR42m2RTU7EMAyFeyGOwGXmDnMHjsYCIRYsEDASYjPSaJqETv7j5I2TtoFqeFJlybU/PztDzhkpJTgfIKWENgYxJtR8lTEacjxCi3c4e2m5nAkhRhhrIcSZowNRRikFg2WAUqoB1s9ygRAjqHB3OIGe7kGPd8jmowHH8QzvPTJDvD62AUr9YJomDETUHFY55zq0NtSJ7AclCWR3AEpsdTGGXme0aHUpRYQQMGBRTdYJNblRBZ941W8JKLMUz6GamS66xVXD317nfL/db1cEve5Bzztk+bL8yt2E5a3mTf4BCn4U3x2W1Tro6wH0uecbvm2AiR9GCAnqJm4cuo19bNE32t56Bl4Bd2UiBaq1jrYAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img29' title='' src='/static/01a41af820e7d2cd5a5323be665fdc28/a6d36/img29.png' srcset='/static/01a41af820e7d2cd5a5323be665fdc28/222b7/img29.png 163w,\n/static/01a41af820e7d2cd5a5323be665fdc28/ff46a/img29.png 325w,\n/static/01a41af820e7d2cd5a5323be665fdc28/a6d36/img29.png 650w,\n/static/01a41af820e7d2cd5a5323be665fdc28/e548f/img29.png 975w,\n/static/01a41af820e7d2cd5a5323be665fdc28/6bfd0/img29.png 1011w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>â— A cada operaÃ§Ã£o merge, sÃ£o feitas duas atribuiÃ§Ãµes:\nâ—‹ pai[i] = x;\nâ—‹ tam[j] = y;\nâ— Sendo assim, basta salvar os valores antigos em uma pilha, para restaurar se\nfor necessÃ¡rio.\nâ—‹ Uma pilha para o vetor pai: &#x3C; ğ‘–, ğ‘ğ‘ğ‘–[ğ‘–] >\nâ—‹ Uma pilha para o vetor tam: &#x3C; ğ‘—, ğ‘¡ğ‘ğ‘š[ğ‘—] >\nâ— NÃ£o permite usar path compression.</p>\n<pre><code class=\"language-C++\">int pai[MAX_N + 1];\nint tam[MAX_N + 1];\nstack&#x3C;pair&#x3C;int, int> > old_pai;\nstack&#x3C;pair&#x3C;int, int> > old_tam;\nvoid init()\n{\n    for(int i = 1; i &#x3C;= MAX_N; i++)\n    {\n        pai[i] = i;\n        tam[i] = 1;\n    }\n}\nint find(int x)\n{\n    if (pai[x] == x)\n    return x;\n    return find(pai[x]);\n}\nvoid merge(int u, int v)\n{\n    int a = find(u);\n    int b = find(v);\n    if (tam[a] > tam[b])\n        swap(a,b);\n    old_pai.emplace(a, pai[a]);\n    old_tam.emplace(b, tam[b]);\n    pai[a] = b;\n    tam[b] += tam[a];\n}\nvoid rollback()\n{\n    auto paiAnt = old_pai.top();\n    auto tamAnt = old_tam.top();\n    pai[paiAnt.first] = paiAnt.second();\n    tam[tamAnt.first] = tamAnt.second();\n    old_pai.pop();\n    old_tam.pop();\n}\n</code></pre>\n<h3>PersistÃªncia parcial</h3>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/ebfff7e7d3181a6c8256382c01051765/2bef9/img30.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.44171779141104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABoElEQVR42o1SXWvbQBDU/39v8pDmoU95KLjQ/gKHUvJg0oYU28XEEGhpbEl3km193Em+yc7KZxNCIAvL3s7tzI1Ol4xGIyyXD2A416DrOs2+76X6Q3ZvZi8ZhDv7u8bkfoqk8zXW/++Qr2dIWdM5bLbQ3sjapH/wngghqIlEVuKsRp6lyPMURZEjy1YwJpW6RllYWFsIXghmUJblsLYGbdu+Ek72+70IOh201mqNRCNCm81We+4ZY1VsWBvUdX10x1RB7z1aEeQmLTM6qb5p4AWLLkhoBHPOa41BM43MbHc7vVN1yGTDymDlZXdyGMWjA/0RPExwxThLIyIa+QkXji7llKNDwUhi0kF0GGfaA8bwVQUvODX0p0QyidFhxGJ9KSgGNuVJ0A9PrBKnnE1C6A8bHOan9IgYe+InLGAvZLcpjlgIg4laBZ08GxLlMrYVHYbTu+JQK2TfHzFuOxmu2u7FU6HkruH9BiRP8xF+js/w+8cFsuVXZA9DTm8+4tf1OVaLL9rny29YTD7hdvwBj/dX2sfZ2c0l7r5f4N/0M54BpWFQSeAb2CIAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img30' title='' src='/static/ebfff7e7d3181a6c8256382c01051765/a6d36/img30.png' srcset='/static/ebfff7e7d3181a6c8256382c01051765/222b7/img30.png 163w,\n/static/ebfff7e7d3181a6c8256382c01051765/ff46a/img30.png 325w,\n/static/ebfff7e7d3181a6c8256382c01051765/a6d36/img30.png 650w,\n/static/ebfff7e7d3181a6c8256382c01051765/e548f/img30.png 975w,\n/static/ebfff7e7d3181a6c8256382c01051765/2bef9/img30.png 1024w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/83aa111634a8df829de307f5079718c5/2bef9/img31.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.44171779141104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA+UlEQVR42qVSy07EMAzs/39MD0j8BQcQEgUBPa1ElebZLW3egxMtnIBGWksjexJn7Djp+r7HOL6hmHM7QggVMcZL7H/4r6C9TGeHE8Pd4xO64DewjweIeSB/Dzk/Q/JXCDbQGsXzC1os51wLdIXY/ROcM2gtoZSAkhyMTZVLijnnsNY1CXdF2VpLQhrGGCxmgdGGhGTlSilM04R1XdsEjxJSSti2DYIKlMLNgqXTgu+4+hRhqpBDovl476/rMMcATdfdd1uLXC1YLFw6K19nOZ/rSx48SsQRaJIk6iAEp3mulf+V26HRYkxwPh5fmb/foAnj//tivK3+CzOaVzrF7OE3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img31' title='' src='/static/83aa111634a8df829de307f5079718c5/a6d36/img31.png' srcset='/static/83aa111634a8df829de307f5079718c5/222b7/img31.png 163w,\n/static/83aa111634a8df829de307f5079718c5/ff46a/img31.png 325w,\n/static/83aa111634a8df829de307f5079718c5/a6d36/img31.png 650w,\n/static/83aa111634a8df829de307f5079718c5/e548f/img31.png 975w,\n/static/83aa111634a8df829de307f5079718c5/2bef9/img31.png 1024w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>â— OperaÃ§Ãµes bÃ¡sicas:\nâ—‹ merge(x, y): conecta os conjuntos de x e y (criando uma nova\nâ€œversÃ£oâ€)\nâ—‹ find(x, t): retorna a qual conjunto x pertence no momento t\nâ—‹ same(x, y, t): verifica se x e y pertencem ao mesmo conjunto no momento t</p>\n<pre><code class=\"language-C++\">int pai[MAX_N + 1];\nint tam[MAX_N + 1];\nint his[MAX_N + 1];\nint tempo;\nvoid init()\n{\n    tempo = 0;\n    for(int i = 1; i &#x3C;= MAX_N; i++)\n    {\n        pai[i] = i;\n        tam[i] = 1;\n        his[i] = 0;\n    }\n}\nint find(int x, int t)\n{\n    if (pai[x] == x) return x;\n    if (his[x] > t) return x;\n    return find(pai[x]);\n}\nvoid merge(int u, int v)\n{\n    tempo++;\n    int a = find(u, tempo);\n    int b = find(v, tempo);\n    if (tam[a] > tam[b])\n        swap(a,b);\n    pai[a] = b;\n    his[a] = tempo;\n    tam[b] += tam[a];\n}\n</code></pre>\n<h3>Pictionary (Gym - 102078A)</h3>\n<p>â— Neste problema, temos um conjunto de N cidades, inicialmente todas\ndesconectadas.\nâ— Rodovias sÃ£o construÃ­das entre a cidades em M dias. Em um dia i, Ã©\nconstruÃ­da uma estrada entre ğ‘ e ğ‘ se ğ‘”ğ‘ğ‘‘(ğ‘, ğ‘) = ğ‘€ âˆ’ ğ‘– + 1.\nâ— SÃ£o feitas Q queries, constituÃ­das por pares de cidades. O resultado de cada\nquery Ã© o nÃºmero mÃ­nimo de dias necessÃ¡rios para conectar o par de\ncidades (direta ou indiretamente)\nâ— Usaremos disjoint-sets com persistÃªncia parcial para unir as cidades\nmarcando o momento em que as uniÃµes foram feitas.\nâ—‹ Para cada dia ğ‘‘, vamos conectar as cidades com gcd(ğ‘, ğ‘) = ğ‘€ âˆ’ ğ‘‘ + 1, que vamos\nchamar de ğ‘¥. Iterando sobre ğ‘‘, vamos realizar um merge de ğ‘¥ com todos os seus\nmÃºltiplos (atÃ© n).\nâ—‹ Mas e se duas cidades (ğ‘¥, ğ‘˜. ğ‘¥) jÃ¡ tiverem sido conectadas indiretamente antes? Sem\nproblemas, o merge vai verificar que as cidades jÃ¡ foram unidas em um momento\nanterior e nÃ£o vai fazer nada.\nâ— Para realizar as queries, executaremos uma busca binÃ¡ria para descobrir o\nnÃºmero mÃ­nimo de dias necessÃ¡rios para conectar as cidades ğ‘ e ğ‘.</p>\n<h3>SoluÃ§Ã£o Offline</h3>\n<p>â— Quando lidamos com problemas em que a entrada consiste em uma\nsequÃªncia de queries, temos dois tipos de soluÃ§Ãµes possÃ­veis:\nâ—‹ Online: cada query Ã© processada no momento em que Ã© lida, antes da\nleitura da prÃ³xima.\nâ—‹ Offline: todas as queries sÃ£o lidas para sÃ³ depois serem processadas. E\neste processamento pode ser realizado em uma ordem conveniente,\nnÃ£o necessariamente na ordem de entrada.\nâ–  Ajuda a resolver certos problemas de forma mais eficiente</p>\n<h3>Consecutive Letters (SPOJ â€“ CONSEC)</h3>\n<p>â— Problema: considere uma string S apenas com letras maiÃºsculas. SÃ£o dadas\nQ queries, e cada query pode ser de dois tipos:\nâ—‹ 1 i: encontre o tamanho mÃ¡ximo do segmento [b, e] em que a substring\nS[b...e] contenha apenas a letra S[i].\nâ—‹ 2 i: Troque o caractere no Ã­ndice i por â€˜#â€™\nâ— |ğ‘†| â‰¤ 200000\nâ— ğ‘„ â‰¤ 100000\nâ— Uma forma de modelar este problema Ã© utilizando uma DSU, de forma que\numa sequÃªncia contÃ­gua de caracteres iguais estejam em um mesmo\nconjunto.\nâ— O problema Ã© que a segunda query representa uma possÃ­vel cisÃ£o de um\ndestes conjuntos, e a DSU permite realizar uniÃµes de conjuntos, mas nÃ£o\nseparaÃ§Ãµes.\nâ— PorÃ©m, uma soluÃ§Ã£o offline pode resolver este problema.\nâ— Basta ler todas as queries e processÃ¡-las na ordem inversa. Dessa forma\niniciamos com a string jÃ¡ alterada, com todas as substituiÃ§Ãµes por â€˜#â€™ jÃ¡\nrealizadas, e vamos realizando as operaÃ§Ãµes de trÃ¡s para frente.\nâ—‹ 1 i: imprimimos o tamanho do conjunto a qual a posiÃ§Ã£o i faz parte\nâ—‹ 2 i: voltamos o caractere original da posiÃ§Ã£o i, e entÃ£o:\nâ–  S[i] == S[i-1] â†’ merge(i, i-1)\nâ–  S[i] == S[i+1] â†’ merge(i, i+1)</p>\n<h3>ReferÃªncias</h3>\n<p><a href=\"https://files.johnjq.com/slides/summer/union-find.pdf\">https://files.johnjq.com/slides/summer/union-find.pdf</a>\n<a href=\"https://github.com/icmcgema/gema/blob/master/XX-Union_Find.md\">https://github.com/icmcgema/gema/blob/master/XX-Union_Find.md</a>\n<a href=\"https://cp-algorithms.com/data_structures/disjoint_set_union.html\">https://cp-algorithms.com/data_structures/disjoint_set_union.html</a>\n<a href=\"https://www.youtube.com/watch?v=E33jZUw2l9Q\">https://www.youtube.com/watch?v=E33jZUw2l9Q</a></p>"}},"pageContext":{"id":"7444ff95-a5d9-55c1-ba66-3946e57417f9","frontmatter__slug":"disjoint-set-union","__params":{"frontmatter__slug":"disjoint-set-union"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}