{"componentChunkName":"component---src-pages-aprender-07-programacao-dinamica-2-markdown-remark-frontmatter-slug-tsx","path":"/aprender/07-programacao-dinamica-2/exercicios-x/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Exercícios X","description":"descricao","author":null},"html":"<h1>Explicação dos Exercícios de Grafo</h1>\n<h2>Exercícios B, D e G</h2>\n<h3>B - Find the Treasure</h3>\n<p>img1 - img7 (montar gif)\n<img src=\"/static/gif1-96f22cdd86bb32c9c2cf47e7061c9a03.gif\" alt=\"gif1\"></p>\n<h3>BFS partindo de múltiplas fontes</h3>\n<p>● Seu funcionamento é exatamente igual ao da BFS.\n● No entanto, ao invés de começar em um único nó, todos os\nvértices que considerarmos como ínicio serão inseridos na\nfila de processamento.\n● Útil para resolução de problemas que requerem o cálculo\nda mínima distância ou custo para se chegar a um vértice.</p>\n<p>img8 - img18 (montar gif)\n<img src=\"/static/gif2-8650b5a3e4c12798eb859438c1d89d3c.gif\" alt=\"gif2\"></p>\n<pre><code class=\"language-C++\">void bfs(const vector&#x3C;int> &#x26;sources) {\n    queue&#x3C;int> q;\n    vector&#x3C;int> dist;\n    for (auto s : sources) {\n        dist[s] = 0;\n        q.push(s);\n    }\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (auto v : adj[u]) {\n            if (dist[u] + 1 &#x3C; dist[v]) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n}\n</code></pre>\n<h3>D - Police Stations</h3>\n<p>img19 - img33 (montar gif)\n<img src=\"/static/gif3-2a0bb585e771bc806dd1be667bda7b38.gif\" alt=\"gif3\"></p>\n<h3>G - Jane and the Frost Giants</h3>\n<p>● Jane está presa em um labirinto que contém armadilhas de\nfogo, espalhando uma célula para o lado, nas direções\nvertical e horizontal, a cada minuto.\n● Jane leva um minuto para andar para uma célula adjacente.\n● Determinar o tempo mínimo para Jane escapar por uma das\nbordas do labirinto, se possível.\n● Estratégia: computar o tempo mínimo que demora para uma\ncélula pegar fogo a partir de cada armadilha.\n● Após isso, computar o tempo mínimo que leva para Jane\nalcançar uma célula adjacente e se é possível alcançá-la\nantes do fogo.\n● Verificar se ela consegue chegar em alguma borda.</p>\n<p>img34 - img46 (montar gif)\n<img src=\"/static/gif4-e8d6099a1316fb1ca256a17f63faaa04.gif\" alt=\"gif4\"></p>\n<pre><code class=\"language-C++\">int main() {\n    int T;\n    cin >> T;\n    for (int t = 1; t &#x3C;= T; t++) {\n        cin >> r >> c;\n        grid = vector &#x3C;string >(r + 1);\n        for (int i = 0; i &#x3C; r; i++)\n            cin >> grid[i];\n        vii fire, jane;\n        for (int i = 0; i &#x3C; r; i++) {\n            for (int j = 0; j &#x3C; c; j++) {\n                if (grid[i][j] == 'F')\n                    fire.push_back ({i, j});\n                else if (grid[i][j] == 'J')\n                jane.push_back ({i, j});\n            }\n        }\n        int minutes;\n        dist = vector &#x3C;vi>(r + 1, vi(c + 1, INF));\n        bfs(fire, false);\n        minutes = bfs(jane, true);\n        cout &#x3C;&#x3C; \"Case \" &#x3C;&#x3C; t &#x3C;&#x3C; \": \";\n        if (minutes != INF)\n            cout &#x3C;&#x3C; minutes + 1 &#x3C;&#x3C; \"\\n\";\n        else\n            cout &#x3C;&#x3C; \"IMPOSSIBLE \\n\";\n    }\n    return 0;\n}\nint bfs(const vii &#x26;sources , bool jane) {\n    int minutes = INF;\n    queue&#x3C;ii> q;\n    for (auto [i, j] : sources) {\n        dist[i][j] = 0;\n        q.push({i, j});\n    }\n    while (!q.empty()) {\n        int i, j;\n        tie(i, j) = q.front();\n        q.pop();\n        if (jane &#x26;&#x26; (i == 0 || i == r - 1 || j == 0 || j == c -\n        1))\n            minutes = min(dist[i][j], minutes);\n        for (auto [x, y] : dir) {\n            int a, b;\n            a = i + x;\n            b = j + y;\n            if (a >= 0 &#x26;&#x26; a &#x3C; r &#x26;&#x26; b >= 0 &#x26;&#x26; b &#x3C; c &#x26;&#x26; grid[a][b]\n            == '.' &#x26;&#x26; dist[i][j] + 1 &#x3C; dist[a][b]) {\n                dist[a][b] = dist[i][j] + 1;\n                q.push({a, b});\n            }\n        }\n    }\n    return minutes;\n}\n</code></pre>"}},"pageContext":{"id":"24cc54d7-c253-5ef5-a830-5bf70f9ac3c2","frontmatter__slug":"exercicios-x","__params":{"frontmatter__slug":"exercicios-x"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}