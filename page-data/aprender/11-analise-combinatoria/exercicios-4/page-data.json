{"componentChunkName":"component---src-pages-aprender-11-analise-combinatoria-markdown-remark-frontmatter-slug-tsx","path":"/aprender/11-analise-combinatoria/exercicios-4/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"02 - Exercícios","description":"descricao","author":null},"html":"<h2>Resolução dos Exercícios</h2>\n<h3>Exercícios: E e F</h3>\n<h3>F - Factorials and Powers of Two</h3>\n<ul>\n<li>\n<p>Um número é considerado powerful se:</p>\n<ul>\n<li>Potência de dois ou,</li>\n<li>Fatorial</li>\n</ul>\n</li>\n<li>\n<p>ou seja, o número m é powerful se existe um inteiro d não negativo:</p>\n<ul>\n<li>m = 2^d ou,</li>\n<li>m = d!</li>\n</ul>\n</li>\n<li>\n<p>Dado um valor n, encontre o mínimo número k tal que n possa ser representado como a soma de k números distintos que são powerful.</p>\n</li>\n<li>\n<p>Exemplos:</p>\n</li>\n</ul>\n<p>240 = 24 + 32 + 64 + 120 (k = 4)</p>\n<p>240 = 120 + 120 (INVÁLIDO)</p>\n<p>7 = 1 + 2 + 4 (k = 3)\n7 = 1 + 6 (k = 2)\nSolução: 2</p>\n<ul>\n<li>Se n não pode ser representado pela soma de distintos números powerful, print -1</li>\n<li>Essa situação nunca irá acontecer pois qualquer número inteiro pode ser representado pela soma de potências de dois.</li>\n</ul>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/fdb3054aea4eb15c0f5d7b98dd34c364/afa26/img1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 31.901840490797547%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQ0lEQVR42j2RyW4UQQxA5/+/hQuHCJELlwhxYlFIWKTREIiydNfm6lq6ppeHuyPlZpXtV8/2YcyG25trava0Yvn544ZpdEQxPD3ew5oQ3+NcB3Pk+emeQTqWKWJtr7WWZj/h/n7Q9HcOrTpOpxNjHTQpHI9HzqMnZ8FoA2tGgkMkwDLgvdPPgwITKWfmpiL2CnN3yRK/cDiXfm/YYC13CkrMo6EmpyaWpVnGEhQi+7uEnjL0GjvSICxjT/h3yZ/rN6yvQG/UKrDFtahpNRQFSjA7sFVRaNyBMWyfvQBrSS/Au/c8/HrLKp8VqCARLZ6qNgaCqEmLnFul1so6J4YYKCWzTgMxRgWp2ZRxfrP2nN1HHo/vdOSvClQbb7vXkb0ufzPc4GXbVdMDhY4UHavGW34fWXdnTcdce8b+ioffF3qUb/wHAZDIn7Xh+6kAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img1' title='' src='/static/fdb3054aea4eb15c0f5d7b98dd34c364/a6d36/img1.png' srcset='/static/fdb3054aea4eb15c0f5d7b98dd34c364/222b7/img1.png 163w,\n/static/fdb3054aea4eb15c0f5d7b98dd34c364/ff46a/img1.png 325w,\n/static/fdb3054aea4eb15c0f5d7b98dd34c364/a6d36/img1.png 650w,\n/static/fdb3054aea4eb15c0f5d7b98dd34c364/e548f/img1.png 975w,\n/static/fdb3054aea4eb15c0f5d7b98dd34c364/afa26/img1.png 1258w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li>\n<p>Sendo assim, a quantidade de bits ativos no número n como o mínimo valor para k.</p>\n</li>\n<li>\n<p>A solução ótima pode ser formada por uma das seguintes situações:</p>\n</li>\n<li>\n<p>Situação 1:</p>\n<ul>\n<li>Soma somente de valores potências de dois.</li>\n</ul>\n</li>\n<li>\n<p>Situação 2:</p>\n<ul>\n<li>Soma somente de valores que são fatoriais.</li>\n</ul>\n</li>\n<li>\n<p>Situação 3:</p>\n<ul>\n<li>Soma de potências de dois com soma de fatoriais.</li>\n</ul>\n</li>\n<li>\n<p>Situação 1: Soma somente de valores potências de dois.</p>\n<ul>\n<li>Esse é nosso limite inferior de k, podemos calcular contando quais são os bits ativos de n.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-C++\">ll bits_ativos(ll n){\n    ll x = 0, pot = 1, k = 0;\n    while (n > x){\n        if (num &#x26; (pot)){\n            x += (pot);\n            k++;\n        }\n        pot *= 2;\n    }\n    return k;\n}\n</code></pre>\n<ul>\n<li>Equivalente com complexidade O(numero_de_bits) :</li>\n</ul>\n<pre><code class=\"language-C++\">ll bits_ativos(ll n){\nreturn __builtin_popcountll(n);\n}\n</code></pre>\n<p><a href=\"https://www.geeksforgeeks.org/builtin-functions-gcc-compiler/\">Builtin functions of GCC compiler</a></p>\n<ul>\n<li>Situação 2: Soma somente de valores que são fatoriais.</li>\n<li>Primeiro, precisamos saber quais são os fatoriais possíveis. No problema é descrito que n &#x3C;= 10¹² , logo, precisamos apenas pré-calcular até o fatorial 14!, já que 15! = 1.307.674.368.000 > 10¹².</li>\n</ul>\n<pre><code class=\"language-C++\">#define MAX_FAC 14\nfac = vector&#x3C;ll>(MAX_FAC + 1);\nvoid pre_processar_fatoriais(){\n    ll x = 1;\n    for (int i = 1; i &#x3C;= MAX_FAC; i++){\n        x *= i;\n        fac[i] = x;\n    }\n}\n</code></pre>\n<ul>\n<li>Todos fatoriais que podem ser usados no problema:</li>\n</ul>\n<p>Fatoriais (14) = {1, 2, 6, 24, 120, 720, 5040,\n40320, 362880, 3628800, 39916800,\n479001600, 6227020800, 87178291200}</p>\n<ul>\n<li>Situação 2: Soma somente de valores que são fatoriais.\n<ul>\n<li>Como o número de fatoriais possíveis é 14, conseguimos pré-calcular todas as somas possíveis entre esses fatoriais. Ou seja, gerar todos subsets de soma possíveis para os 14 números. O(2¹⁴ ), como 2¹⁴ = 16.384, passa tranquilo no problema.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-C++\">void subset_sum_fac(ll x){\nif (x == MAX_FAC+1){\n    ll sum = 0;\n    for (int i = 0; i &#x3C; subset.size(); i++){\n        sum += fac[subset[i]];\n    }\n    if(fac_sub[sum]!=0)\n        fac_sub[sum] = min(fac_sub[sum],subset.size());\n    else\n        fac_sub[sum] = subset.size();\n}\nelse{\n    subset.push_back(x);\n    subset_sum_fac(x + 1);\n    subset.pop_back();\n    subset_sum_fac(x + 1);\n    }\n}\n</code></pre>\n<ul>\n<li>Situação 3: Soma de potências de dois com soma de fatoriais\n<ul>\n<li>Como todas as somas de todos possíveis fatoriais podem ser salvas em um map, podemos passar por cada uma das somas que encontramos na Situação 2 e calcular um número x que diz quanto falta para a soma da Situação 2 chegar em n. Assim, conseguimos calcular para x a Situação 1.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-C++\">for (map&#x3C;ll, ll>:: iterator itr =\nfac_sub.begin();itr!=fac_sub.end();++itr)\n{\n    ll a = itr->first;\n    if (a > n) break;\n    ll x = n - a; //Quanto falta para a soma 'a' chegar em 'n'\n    minimo = min(minimo, bits_ativos(x) + fac_sub[a]);\n}\n\nSit_1 = bits_ativos();\n\nSit_2 = todas_somas_possiveis_dos_fatoriais\n    for(i=0;i&#x3C;=Sit_2.size();i++)\n    Sit_3 = min(Sit_3, Sit_2 [i] + Sit_1 (n - Sit_2 [i]))\nk_minimo = min (Sit_1(n) , Sit_3 )\n</code></pre>\n<h3>E - Su Doku</h3>\n<ul>\n<li>\n<p>Dado um valor N e uma grade N 2 xN 2 de um Sudoku parcialmente resolvida, o objetivo é completar o quebra-cabeças, inserindo números de 1 até N 2 nas células vazias de modo que:</p>\n</li>\n<li>\n<p>todos os números que compõem uma linha sejam distintos;</p>\n</li>\n<li>\n<p>todos os números que compõem uma coluna sejam distintos;</p>\n</li>\n<li>\n<p>todos os números que componham uma subgrade de tamanho NxN sejam distintos.</p>\n</li>\n<li>\n<p>Confira na GIF abaixo:</p>\n</li>\n</ul>\n<p><img src=\"/static/gif1-420bb72aa5343eaf0cddf3a3a69ab621.gif\" alt=\"img2 - img44\"></p>\n<pre><code class=\"language-C++\">int main() {\n    // leitura do tamanho do tabuleiro e alocação da matriz do Sudoku\n    while (cin >> n) {\n        n *= n;\n        sudoku = vector&#x3C;vector&#x3C;int>>(n, vector&#x3C;int>(n));\n        // leitura do Sudoku\n        for (int i = 0; i &#x3C; n; i++)\n            for (int j = 0; j &#x3C; n; j++)\n                cin >> sudoku[i][j];\n        // se o tabuleiro apresentar solução\n        if (solve(0, 0)) {\n            // imprime a solução\n            for (int i = 0; i &#x3C; n; i++) {\n                for (int j = 0; j &#x3C; n; j++)\n                    cout &#x3C;&#x3C; sudoku[i][j] &#x3C;&#x3C; \" \";\n            cout &#x3C;&#x3C; \"\\n\";\n            }\n        } else\n            // caso contrário, imprime que não há solução viável\n        cout &#x3C;&#x3C; \"NO SOLUTION\\n\";\n        }\n    return 0;\n}\n\nbool solve(int row, int col) {\n    // verifica se chegou ao final da coluna atual\n    if (col == n) {\n        // se sim, pula para a linha de baixo e volta para primeira coluna\n        col = 0;\n        row++;\n        // caso passe da última linha, o quebra-cabeças tem solução e \n        // retorna verdadeiro\n        if (row == n)\n            return true;\n    }\n    // verifica se a célula atual é uma célula vazia\n    if (sudoku[row][col] == 0) {\n        // sendo uma célula vazia, vamos tentar inserir valores de 1 \n        // até n^2 nela\n        for (int i = 1; i &#x3C;= n; i++) {\n            // verificamos se é possível inserir o valor i, respeitando as \n            // regras do jogo\n            if (verify(row, col, i)) {\n                // em caso afirmativo, alteramos o valor da célula\n                sudoku[row][col] = i;\n                // e tentamos resolver a próxima casa\n                if (solve(row, col + 1))\n                    return true;\n            }\n        }\n        // se nenhum valor retornar uma solução válida, esvaziamos a casa\n        sudoku[row][col] = 0;\n    } else\n        // se já é uma célula com valor, avançamos para a próxima \n        // coluna apenas\n        return solve(row, col + 1);\n    // se o código chegar até aqui, quer dizer que, para o tabuleiro no \n    // estado atual, não tem solução\n    // assim, retornamos na recursão, e tentamos achar uma solução para \n    // próxima configuração\n    return false;\n}\n\nbool verify(int row, int col, int elem) {\n    for (int i = 0; i &#x3C; n; i++) {\n        // verifica se existem elementos repetidos na linha\n        // caso exista elemento repetido, retorna falso\n        if (sudoku[i][col] == elem)\n            return false;\n        // verifica se existem elementos repetidos na coluna\n        else if (sudoku[row][i] == elem)\n            return false;\n    }\n    // determina o inicio da linha e da coluna do subquadrado atual\n    int sq, sub_row, sub_col;\n    sq = sqrt(n);\n    sub_row = row / sq * sq;\n    sub_col = col / sq * sq;\n    // verificar se existem elementos repetidos no subquadrado\n    for (int i = sub_row; i &#x3C; sub_row + sq; i++) {\n        for (int j = sub_col; j &#x3C; sub_col + sq; j++) {\n        // caso exista elemento repetido, retorna falso\n            if (sudoku[i][j] == elem)\n                return false;\n        }\n    }\n    // se chegou até aqui, todas as especificações foram atendidas e retorna \n    // verdadeiro\n    return true;\n}\n</code></pre>\n<ul>\n<li>Complexidade: O(N^M), onde N é quantidade de números possíveis de serem inseridos em cada célula do Sudoku e M a quantidade de células vazias. Ex: Sudoku resolvido, 9x9 com 63 casas vazias, teria complexidade O(9⁶³ ).</li>\n</ul>"}},"pageContext":{"id":"24a6daf4-f023-513b-afb8-bb4989b876f9","frontmatter__slug":"exercicios-4","__params":{"frontmatter__slug":"exercicios-4"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}