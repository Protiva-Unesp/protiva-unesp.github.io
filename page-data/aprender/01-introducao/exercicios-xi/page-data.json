{"componentChunkName":"component---src-pages-aprender-01-introducao-markdown-remark-frontmatter-slug-tsx","path":"/aprender/01-introducao/exercicios-xi/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"04 - Exercícios 2","description":"descricao","author":null},"html":"<h2>Explicação dos Exercícios de Grafo</h2>\n<h3>Exercícios B, D, E e F</h3>\n<h3>B - Roads of NITT</h3>\n<ul>\n<li>\n<p>Existem N hotels conectados entre si por N - 1 arestas.</p>\n</li>\n<li>\n<p>No início, sempre existe um caminho entre dois pares de hotéis, mas, com o tempo, algumas rotas se tornam inutilizáveis.</p>\n</li>\n<li>\n<p>Dadas Q consultas, determinar quantos pares de hotéis (X, Y) não tem uma rota entre si.</p>\n</li>\n<li>\n<p>As consultas podem ser de 2 tipos:</p>\n<ul>\n<li>R X -> remove a estrada X. É garantido que ela não foi removida anteriormente.</li>\n<li>Q -> retorna o resultado do número de pares de hotéis (X, Y) que não possuem rota entre si.</li>\n</ul>\n</li>\n<li>\n<p>Confira a GIF abaixo:</p>\n</li>\n</ul>\n<p><img src=\"/static/gif1-51188587f662e8a7b09fd0e27c3d8c00.gif\" alt=\"img1-img23\"></p>\n<pre><code class=\"language-C++\">ll q;\ncin >> q;\nvector&#x3C;bool> used(n);\nvi queries(q);\nfor (ll i = 0; i &#x3C; q; i++) {\n    char op;\n    ll id = -1;\n    cin >> op;\n    if (op == 'R') {\n        cin >> id;\n        used[id] = true;\n    }\n    queries[i] = id;\n}\nll conn = 0;\nfor (ll i = 1; i &#x3C; n; i++) {\n    if (!used[i]) {\n        int u, v;\n        tie(u, v) = edges[i];\n        u = find(u);\n        v = find(v);\n        if (u != v) {\n            conn += len[u] * len[v];\n            unite(u, v);\n        }\n    }\n}\nfor (int i = 1; i &#x3C;= n; i++) {\n    find(i);\n}\nll tot = n * (n - 1) / 2 - conn;\nstack&#x3C;ll> ans;\nfor (ll i = q - 1; i >= 0; i--) {\n    ll id = queries[i];\n    if (id != -1) {\n        ll u, v;\n        tie(u, v) = edges[id];\n        u = find(u);\n        v = find(v);\n        if (u != v) {\n            tot -= len[u] * len[v];\n            unite(u, v);\n        }\n    } else {\n    ans.push(tot);\n    }\n}\nwhile (!ans.empty()) {\n    cout &#x3C;&#x3C; ans.top() &#x3C;&#x3C; \"\\n\";\n    ans.pop();\n}\ncout &#x3C;&#x3C; \"\\n\";\n</code></pre>\n<h3>E - Spanning Tree Fraction</h3>\n<ul>\n<li>Temos um grafo conexo G com N vértices, indexados de 0 até N - 1, e M arestas.</li>\n<li>Cada aresta desse grafo é uma quádrupla (U, V, a, b), sendo U o vértice de origem, V o vértice de destino, a e b pesos da nossa aresta.</li>\n<li>Achar uma árvore geradora T que contém um subconjunto das M arestas e maximize a expressão ∑i∈T ai / ∑i∈T bi, sendo i o índice da aresta inserida em T.</li>\n<li>Escrever o termo resultante no formato de uma fração irredutível p / q.</li>\n</ul>\n<pre><code class=\"language-C++\">bool cmp(tuple&#x3C;ii, ll, ll> a, tuple&#x3C;ii, ll, ll> b) {\n    ii p, q;\n    p = get&#x3C;0>(a);\n    q = get&#x3C;0>(b);\n    return (p.first - p.second * x) > (q.first - q.second * x);\n}\nint main() {\n    ll n, m;\n    cin >> n >> m;\n    parent = len = vi(n + 1);\n    for (ll i = 0; i &#x3C; m; i++) {\n        ll u, v, a, b;\n        cin >> u >> v >> a >> b;\n        add_edge(u, v, a, b);\n    }\n    ll p, q, gcd;\n    double left = 0., right = 1e7;\n    while (fabs(right - left) >= EPSILON) {\n        x = (left + right) / 2;\n        for (ll i = 0; i &#x3C;= n; i++) {\n            parent[i] = i;\n            len[i] = 1;\n        }\n        p = q = 0;\n        sort(begin(edges), end(edges), cmp);\n        kruskal(p, q);\n        if (p >= q * x) {\n            left = x;\n        } else {\n            right = x;\n        }\n    }\n    gcd = __gcd(p, q);\n    p /= gcd;\n    q /= gcd;\n    cout &#x3C;&#x3C; p &#x3C;&#x3C; \"/\" &#x3C;&#x3C; q &#x3C;&#x3C; \"\\n\";\n    return 0;\n}\n</code></pre>\n<h3>F - Airports</h3>\n<ul>\n<li>\n<p>Você pode colocar aeroportos em qualquer cidade.</p>\n</li>\n<li>\n<p>São dadas as possíveis pistas que ligam as cidades.</p>\n</li>\n<li>\n<p>Objetivo: Garantir que cada cidade tenha acesso a um aeroporto.</p>\n</li>\n<li>\n<p>Confira a GIF abaixo:</p>\n</li>\n</ul>\n<p><img src=\"/static/gif2-6e7c7292323c9fa89d85364257f559d2.gif\" alt=\"img24-img38\"></p>\n<pre><code class=\"language-C++\">for(int i = 0; i &#x3C; m; i++){\n    cin >> a >> b >> c;\n    arestas.push_back({c, a, b});\n}\nsort(arestas.begin(), arestas.end());\nll custo = 0;\nll ind = lower_bound(arestas.begin(), arestas.end(), make_tuple(aer, 1e17, 1e17))\n- arestas.begin();\nfor(int j = 0; j &#x3C; ind; j++){\n    tie(c, a, b) = arestas[j];\n    if(c == aer)continue;\n    if(find(a) != find(b)){\n        merge(a, b);\n        custo += c;\n    }\n}\n</code></pre>"}},"pageContext":{"id":"f32d76ca-e432-5e49-9a20-d6c7f11a141b","frontmatter__slug":"exercicios-xi","__params":{"frontmatter__slug":"exercicios-xi"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}