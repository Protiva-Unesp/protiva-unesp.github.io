{"componentChunkName":"component---src-pages-aprender-01-introducao-markdown-remark-frontmatter-slug-tsx","path":"/aprender/01-introducao/stl-2/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"03 - STL: associativos, iteratores e algoritmos","description":"descricao","author":"Rene Pegoraro, Pedro Henrique Paiola, Wilson M Yonezawa"},"html":"<h3>set</h3>\n<ul>\n<li>Armazenam elementos únicos seguindo uma ordem.</li>\n<li>um critério de comparação precisa ser definido</li>\n</ul>\n<pre><code class=\"language-C++\">#include &#x3C;string>\n#include &#x3C;set>\nusing namespace std;\nint main() {\n    set &#x3C;string> nome;\n    nome.insert(\"joao\");\n    nome.insert(\"maria\");\n    nome.insert(\"jose\");\n    nome.insert(\"pedro\");\n    nome.insert(\"maria\");\n    nome.insert(\"joao\");\n    printf(\"%d\\n\", nome.size());\n    return 0;\n}\n</code></pre>\n<ul>\n<li>O set não armazena elementos repetidos</li>\n<li>No exemplo ao lado, o valor apresentado será 4 (número de elementos no set)</li>\n<li>Se precisar de armazenar repetições, multiset poderá ser usado</li>\n<li>Veja também hash_set</li>\n</ul>\n<h3>set - Formas de Ordenação</h3>\n<pre><code class=\"language-C++\">#include &#x3C;string>\n#include &#x3C;set>\nusing namespace std;\nstruct Par {\n    int a, b;\n    Par(int A, int B) : a(A), b(B) {}\n    bool operator&#x3C;(const Par &#x26;p) const {\n        return b &#x3C; p.b;\n    }\n};\n\nstruct comp {\n    bool operator()(const Par &#x26;p1,\n    const Par &#x26;p2) {\n    return p1.a &#x3C; p2.a;\n    }\n}; // Ordem alternativa indicada pelo “operator()”.\n\nint main() {\n    set&#x3C;Par> conj1;\n    conj1.insert(Par(1, 91));\n    conj1.insert(Par(2, 52));\n    conj1.insert(Par(3, 73));\n    conj1.insert(Par(1, 71));\n    set&#x3C;Par, comp> conj2;\n    conj2.insert(Par(1, 91));\n    conj2.insert(Par(2, 52));\n    conj2.insert(Par(3, 73));\n    conj2.insert(Par(1, 71));\n    printf(\"%ld, %ld\\n\",\n    conj1.size(), conj2.size());\n    return 0;\n}\n</code></pre>\n<h3>Exercício Usando set</h3>\n<ul>\n<li>Resolva o problema URI 2174</li>\n<li>Recomendações</li>\n<li>Use set<string> para definir o conjunto de pomekons.</li>\n<li>Como o conjunto não aceita repetições, basta inserir todos os pokemons na lista, mesmo se repetidos, pois eles serão inseridos apenas uma vez.</li>\n</ul>\n<h3>map</h3>\n<ul>\n<li>Mantém pares chave-valor, sendo cada chave única</li>\n<li>Precisa de um critério de comparação entre as chaves.</li>\n</ul>\n<pre><code class=\"language-C++\">#include &#x3C;cstdio>\n#include &#x3C;map>\n#include &#x3C;string>\nusing namespace std;\nint main () {\n    map&#x3C;string,float> not\n    nota[\"Pedro\"]=10.0;\n    nota[\"Antonio\"]=5.0;\n    nota[\"Maria\"]=7.5;\n    printf(\"%f\\n\", nota[\"Pedro\"]);\n    printf(\"%f\\n\", nota[\"pedro\"]);\n    printf(\"%f\\n\", nota[\"Maria\"]);\n    return 0;\n}\n</code></pre>\n<ul>\n<li>O dicionário não armazena chaves repetidas</li>\n<li>O container multimap armazena repetições</li>\n<li>Usar hash_map e hash_multimap pode melhorar o desempenho mas sem ordenação</li>\n</ul>\n<h3>Exercício Usando map</h3>\n<ul>\n<li>Resolva o problema URI 2727</li>\n<li>Recomendações\n<ul>\n<li>Use map&#x3C;string,char> para definir a relação chave-valor, assim a chave será o código e o valor o caractere</li>\n<li>A iniciação do map pode ser feito manualmente, adicionando os 26 códigos um a um para cada caractere ou programaticamente.</li>\n</ul>\n</li>\n<li>Definindo:\n<ul>\n<li>map&#x3C;string, char> decodifica;</li>\n<li>Manualmente para a letra “i”, seria:</li>\n<li>decodifica[\"... ... ...\"] = 'i';</li>\n<li>Para decodificar, basta ler o código de cada linha em uma string e usá-la como chave</li>\n</ul>\n</li>\n</ul>\n<h3>Iteradores (iterator)</h3>\n<ul>\n<li>Um iterator é qualquer objeto capaz de interagir com os elementos de um container usando um conjunto de operadores</li>\n<li>Uma variável iterator funciona como um ponteiro, “apontando” para cada elemento do container</li>\n<li>Um iterator pode ser incrementado, para indicar o próximo elemento</li>\n</ul>\n<h3>Iterator Mimetiza Aritmética de Ponteiros</h3>\n<pre><code class=\"language-C++\">#include &#x3C;vector>\n#include &#x3C;cstdio>\nusing namespace std;\nfloat vet[] = {7.8, 1.2, 5.6, 9.0, 3.4};\nvector&#x3C;float> vect(&#x26;vet[0], &#x26;vet[5]);\nint main() {\n    for (vector&#x3C;float>::iterator it = vect.begin();\n        it != vect.end(); it++) {\n        printf(\"%5.1f\", *it);\n    }\n    printf(\"\\n\");\n    for (float *it = &#x26;vet[0]; it != &#x26;vet[5]; it++) {\n        printf(\"%5.1f\", *it);\n    }\nprintf(\"\\n\");\n    for (float f: vect) {\n        printf(\"%5.1f\", f);\n    }\n    printf(\"\\n\");\n    for (float f: vet) {\n        printf(\"%5.1f\", f);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\nfloat f: vect => range-based for\na partir do C++11\n</code></pre>\n<p>Obtém-se:</p>\n<pre><code>7.8 1.2 5.6 9.0 3.4\n7.8 1.2 5.6 9.0 3.4\n7.8 1.2 5.6 9.0 3.4\n7.8 1.2 5.6 9.0 3.4\n</code></pre>\n<h3>Iterator com set</h3>\n<pre><code class=\"language-C++\">#include &#x3C;string>\n#include &#x3C;set>\nusing namespace std;\nint main() {\n    set&#x3C;string> nome;\n    nome.insert(\"joao\");\n    nome.insert(\"maria\");\n    nome.insert(\"jose\");\n    nome.insert(\"pedro\");\n    nome.insert(\"maria\");\n    nome.insert(\"joao\");\n    set&#x3C;string>::iterator iter;\n    for (iter = nome.begin(); iter != nome.end(); iter++) {\n        printf(\"%s\\n\", iter->c_str());\n    }\n    return 0;\n}\n</code></pre>\n<p>Obtém-se:</p>\n<pre><code>joao\njose\nmaria\npedro\n</code></pre>\n<h3>Iterator com set</h3>\n<pre><code class=\"language-C++\">#include &#x3C;string>\n#include &#x3C;set>\nusing namespace std;\nstruct Par {\n    int a, b;\n    Par(int A, int B) {\n    a = A;\n    b = B;\n}\nbool operator&#x3C;(const Par &#x26;p)\nconst {\n    return a &#x3C; p.a;\n    }\n};\n\nint main() {\n    set&#x3C;Par> conj;\n    conj.insert(Par(1, 91));\n    conj.insert(Par(2, 52));\n    conj.insert(Par(3, 73));\n    conj.insert(Par(1, 71));\n    for (set&#x3C;Par>::iterator it =\n    conj.begin();\n    it != conj.end(); it++) {\n        printf(\"%d\\t%d\\n\", it->a, it->b);\n    }\n    return 0;\n}\n</code></pre>\n<p>Obtém-se:</p>\n<pre><code>1 91\n2 52\n3 73\n</code></pre>\n<h3>Iterator com multiset</h3>\n<pre><code class=\"language-C++\">#include &#x3C;string>\n#include &#x3C;set>\nusing namespace std;\nstruct Par {\n    int a, b;\n    Par(int A, int B) :\n    a(A), b(B) {}\n    bool operator&#x3C;(const Par &#x26;p)\n    const {\n        return a &#x3C; p.a;\n    }\n};\n\nint main() {\n    multiset&#x3C;Par> cj;\n    cj.insert(Par(3, 73));\n    cj.insert(Par(1, 91));\n    cj.insert(Par(2, 52));\n    cj.insert(Par(1, 71));\n    multiset&#x3C;Par>::iterator it;\n    for (it = cj.begin();\n    it != cj.end(); it++) {\n        printf(\"%d\\t%d\\n\", it->a, it->b);\n    }\n    return 0;\n}\n</code></pre>\n<p>Obtém-se:</p>\n<pre><code>1 91\n1 71\n2 52\n3 73\n</code></pre>\n<h3>Iterator com map</h3>\n<pre><code class=\"language-C++\">#include &#x3C;cstdio>\n#include &#x3C;map>\n#include &#x3C;string>\nusing namespace std;\nint main () {\n    map&#x3C;string,float> nota;\n    nota[\"Pedro\"]=10.0;\n    nota[\"Antonio\"]=5.0;\n    nota[\"Maria\"]=7.5;\n    map&#x3C;string,float>::iterator iter;\n    for (iter = nota.begin(); iter != nota.end(); iter++) {\n        printf(\"%s,\\t%f\\n\", iter->first.c_str(), iter->second);\n    }\n    return 0;\n}\n</code></pre>\n<p>Obtém-se:</p>\n<pre><code>Antonio, 5.000000\nMaria, 7.500000\nPedro, 10.000000\n</code></pre>\n<h3>Iterator com Variáveis auto C++11</h3>\n<pre><code class=\"language-C++\">#include &#x3C;string>\n#include &#x3C;set>\nusing namespace std;\nint main() {\n    set&#x3C;string> nome;\n    nome.insert(\"joao\"); nome.insert(\"maria\"); nome.insert(\"jose\");\n    nome.insert(\"pedro\"); nome.insert(\"maria\"); nome.insert(\"joao\");\n    for (auto iter = nome.begin(); iter != nome.end(); iter++) {\n        printf(\"%s\\n\", iter->c_str());\n    }\n    for (auto iter: nome) { // iter é uma string, não é iterator.\n        printf(\"%s\\n\", iter.c_str());\n    }\n    return 0;\n}\n</code></pre>\n<h3>Iterator com strings</h3>\n<ul>\n<li>Os iterators podem ser usados considerando os caracteres separadamente.</li>\n</ul>\n<pre><code class=\"language-C++\">#include &#x3C;iostream>\n#include &#x3C;string>\n#include &#x3C;algorithm>\nint main () {\n    std::string str (\"Test string\");\n    sort(str.begin(), str.end());\n    for (std::string::iterator it = str.begin(); it != str.end(); ++it)\n        std::cout &#x3C;&#x3C; *it;\n    std::cout &#x3C;&#x3C; '\\n';\n    return 0;\n}\n</code></pre>\n<h3>Exercício Usando iterator e list</h3>\n<ul>\n<li>Resolva o problema onlinejudge 11988</li>\n<li>Recomendações\n<ul>\n<li>Use list<char>.</li>\n<li>Quando um “home” for encontrado, aponte iterator para inserir no início da lista; quando for um “end”, aponte o iterator para o fim da fila. Não esqueça de atualizar o iterado após cada letra inserida.</li>\n</ul>\n</li>\n</ul>\n<h3>Exercício Usando iterator</h3>\n<ul>\n<li>Resolva o problema URI 1244 da forma que deseja, mas utilize iterator para apresentar as palavras</li>\n</ul>\n<h3>Algoritmos</h3>\n<ul>\n<li>Algoritmos que podem ser aplicados aos containers através do iterators</li>\n<li>Podem modificar ou não os dados</li>\n<li>Lista em <a href=\"http://www.cplusplus.com/reference/algorithm/\">http://www.cplusplus.com/reference/algorithm/</a></li>\n</ul>\n<h3>stable_sort</h3>\n<pre><code class=\"language-C++\">#include &#x3C;cstdio>\n#include &#x3C;vector>\n#include &#x3C;algorithm>\nusing namespace std;\nstruct Ponto {\n    float x, y;\n    Ponto(float X, float Y) :\n    x(X), y(Y) {};\n};\nvoid mostra(vector&#x3C;Ponto> s) {\n    vector&#x3C;Ponto>::iterator it;\n    printf(\"-----\\n\");\n    for (it = s.begin();\n    it != s.end(); it++)\n    printf(\"%f\\t%f\\n\", it->x, it->y);\n}\nbool operator&#x3C;(const Ponto &#x26;p1,\nconst Ponto &#x26;p2) {\n    return p1.x &#x3C; p2.x;\n}\nint main() {\n    vector&#x3C;Ponto> lPt;\n    lPt.push_back(Ponto(1.2, 2.3));\n    lPt.push_back(Ponto(4.5, 5.6));\n    lPt.push_back(Ponto(1.2, 1.2));\n    lPt.push_back(Ponto(6.7, 7.8));\n    mostra(lPt);\n    stable_sort(lPt.begin(), lPt.end());\n    mostra(lPt);\n    return 0;\n}\n</code></pre>\n<h3>Exercício Usando stable_sort</h3>\n<ul>\n<li>Resolva o problema URI 1244 usando vector e stable_sort</li>\n<li>Recomendações\n<ul>\n<li>Use vector<string> para definir a lista.</li>\n<li>Use a função stable_sort() que ordenar as palavras.</li>\n</ul>\n</li>\n</ul>\n<h3>replace_if</h3>\n<pre><code class=\"language-C++\">#include &#x3C;iostream>\n#include &#x3C;algorithm>\nusing namespace std;\nbool ehMaior(int i) { return i > 10; }\nint main() {\n    int vet[] = { 10, 90, 4, -10, 25, 93, 10, 7, 0, 33 };\n    for (int i=0; i&#x3C;10; i++)\n        printf(\"%3d \", vet[i]);\n    printf(\"\\n\");\n    replace_if(vet, vet+10, ehMaior, 10);\n    for (int i=0; i&#x3C;10; i++)\n        printf(\"%3d \", vet[i]);\n    return 0;\n}\n</code></pre>\n<p>Obtém-se:</p>\n<pre><code>10 90 4 -10 25 93 10 7 0 33\n10 10 4 -10 10 10 10 7 0 10\n</code></pre>\n<h3>replace_if</h3>\n<pre><code class=\"language-C++\">#include &#x3C;deque>\n#include &#x3C;algorithm>\n#include &#x3C;string>\nusing namespace std;\nbool iniciaComJ(string s) {\n    return s[0] == 'J';\n}\nint main() {\n    deque&#x3C;string> vet;\n    vet.push_back(\"Joao\");\n    vet.push_back(\"Maria\");\n    vet.push_back(\"Pedro\");\n    vet.push_back(\"Jose\");\n    vet.push_back(\"Antonio\");\n    for (auto i = vet.begin();\n        i!=vet.end(); i++)\n    printf(\"%s \", i->c_str());\n    printf(\"\\n\");\n    replace_if(vet.begin(), vet.end(),\n    iniciaComJ, \"XXXX\");\n    for (auto i = vet.begin();\n    i!=vet.end(); i++)\n        printf(\"%s \", i->c_str());\n    return 0;\n}\n</code></pre>\n<p>Obtém-se:</p>\n<pre><code>Joao Maria Pedro Jose Antonio\nXXXX Maria Pedro XXXX Antonio\n</code></pre>\n<h3>Algoritmos e Iteradores</h3>\n<ul>\n<li>Os algoritmos set_difference, set_union, set_intersection, entre outros, realizam operações sobre containers.</li>\n<li>Estas funções recebem iteradores de entrada e saída</li>\n<li>Insert_iterators são iteradores de saída desenvolvidos para permitir que algoritmos que normalmente escrevam elementos possam ser usados para inserir elementos em containers. set_difference(conj1Entra.begin(), conj1Entra.end(), conj2Entra.begin(), conj2Entra.end(), inserter(conjSaida, conjSaida.begin()));</li>\n<li>Veja também: back_inserter, front_inserter e insert_iterator</li>\n<li>Tipos diferentes de destinos podem ser usados, desde que o insert iterator utilize a rotina de inserção correspondente ao container destino</li>\n</ul>\n<pre><code class=\"language-C++\">#include &#x3C;algorithm>\n#include &#x3C;list>\n#include &#x3C;string>\n#include &#x3C;vector>\nusing namespace std;\nint main() {\n    vector&#x3C;string> vet1;\n    vet1.push_back(\"banana\");\n    vet1.push_back(\"pera\");\n    vet1.push_back(\"maça\");\n    string vet2[] = {\"abacaxi\", \"laranja\", \"pera\"};\n    list&#x3C;string> l;\n    set_difference(vet1.begin(), vet1.end(),\n    vet2, vet2 + 3,\n    front_inserter(l));\n. . .\n\n</code></pre>\n<h3>Functores</h3>\n<ul>\n<li>Rotinas que retornam instâncias de classes que implementam o operador () usado em comparações nos algoritmos</li>\n<li>A escolha de um functor indica o que ocorrerá no algoritmo escolhido</li>\n<li>Na omissão de um functor, o less é normalmente usado</li>\n</ul>\n<h3>Functores - greater</h3>\n<pre><code class=\"language-C++\">#include &#x3C;vector>\n#include &#x3C;algorithm>\n#include &#x3C;string>\nusing namespace std;\nint main() {\n    vector&#x3C;string> vet;\n    vet.push_back(\"Joao\");\n    vet.push_back(\"Maria\");\n    vet.push_back(\"Pedro\");\n    vet.push_back(\"Jose\");\n    vet.push_back(\"Antonio\");\n    sort(vet.begin(), vet.end(),\n    greater&#x3C;string>());\n    for (auto i = vet.begin();\n        i!=vet.end(); i++)\n    printf(\"%s \", i->c_str());\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre>\n<p>No vídeo, obtém-se:</p>\n<pre><code>Joao Maria Pedro Jose Antonio\nXXXX Maria Pedro XXXX Antonio\n</code></pre>\n<h3>Containers de containers</h3>\n<ul>\n<li>Em containers de containers é necessário inserir os containers mais internos um a um.</li>\n<li>Por exemplo:\n<ul>\n<li>vector&#x3C;set<int> > adj</li>\n<li>Cria um vetor de conjuntos, mas cada conjunto deve ser inserido explicitamente nos elementos do vector para que possam ser usados</li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"id":"6437e516-20f7-5dd5-8c62-53b259600f53","frontmatter__slug":"stl-2","__params":{"frontmatter__slug":"stl-2"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}