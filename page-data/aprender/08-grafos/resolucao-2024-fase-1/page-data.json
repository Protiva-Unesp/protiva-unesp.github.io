{"componentChunkName":"component---src-pages-aprender-08-grafos-markdown-remark-frontmatter-slug-tsx","path":"/aprender/08-grafos/resolucao-2024-fase-1/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"OBI (Nível Júnior) - Fase 1 - 2024","description":"OBI nível júnior 2024","author":"Miguel Morais Silva Varella"},"html":"<p>1 Tarefa 1: Ogro\n1.1 identificação do Problema\nArquivo: ogro.cpp\nObjetivo: Determinar o resultado de uma brincadeira matemática entre o Ogro e o Bicho-papão,\nbaseada no número de dedos mostrados nas mãos esquerda (E) e direita (D).\n1.2 Análise Lógica\nO problema define duas regras condicionais claras para calcular o resultado:</p>\n<ol>\n<li>Caso 1 (E > D): Se o número de dedos na mão esquerda for maior que na direita, o resultado</li>\n</ol>\n<p>é a soma dos dois números:</p>\n<p>Resultado = E + D</p>\n<ol start=\"2\">\n<li>Caso 2 (E ≤ D): Caso contrário (ou seja, esquerda menor ou igual à direita), o resultado é o</li>\n</ol>\n<p>dobro da diferença entre a direita e a esquerda:</p>\n<p>Resultado = 2 × (D − E)</p>\n<p>As restrições indicam que E e D são números inteiros representando dedos de uma mão, variando\ntipicamente de 0 a 5.</p>\n<p>1.3 Implementação (C++)</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c++ line-numbers\"><code class=\"language-c++\"># include &lt; iostream &gt;\n\nusing namespace std ;\n\nint main () {\nint E , D ;\n\n// Leitura dos valores da mao esquerda e direita\nif ( cin &gt;&gt; E &gt;&gt; D) {\n\n// Verifica a condicao do problema\nif (E &gt; D) {\n// Regra 1: Soma\ncout &lt;&lt; (E + D) &lt;&lt; endl ;\n} else {\n// Regra 2: Dobro da diferenca ( Direita - Esquerda )\ncout &lt;&lt; 2 * (D - E) &lt;&lt; endl ;\n}\n}\nreturn 0;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>1.4 Complexidade\n• Tempo: O(1) - Apenas operações aritméticas básicas e uma condicional.\n• Espaço: O(1) - Apenas duas variáveis armazenadas.</p>\n<p>2 Tarefa 2: Concurso\n2.1 Identificação do Problema\nArquivo: concurso.cpp\nObjetivo: Encontrar a maior nota de corte C possível de modo que pelo menos K candidatos sejam\naprovados, dado um conjunto de N notas.\n2.2 Análise Lógica\nTemos N candidatos e suas respectivas notas. Queremos aprovar os K melhores, mas a nota de corte\ndeve ser tal que inclua esses K candidatos.\nSe ordenarmos as notas em ordem decrescente (da maior para a menor):</p>\n<p>A1, A2, A3, . . . , AK, . . . , AN</p>\n<p>Os primeiros K candidatos (índices 0 a K −1 em um vetor 0-indexado) são os que têm as maiores\nnotas. Para garantir que pelo menos esses K candidatos entrem, a nota de corte deve ser igual à\nnota do K-ésimo candidato na lista ordenada.\nPor que o K-ésimo?\n• Se a nota de corte for maior que AK, menos de K pessoas passarão.\n• Se a nota de corte for igual a AK, então A1 ≥ A2 ≥ · · · ≥ AK. Todos esses K candidatos têm\nnota maior ou igual à nota de corte e serão aprovados.\n• O problema pede a maior nota de corte possível. Qualquer nota menor que AK também\naprovaria os K candidatos, mas AK é o limite superior que satisfaz a condição \"pelo menos K\naprovados\".\n2.3 Implementação (C++)</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c++ line-numbers\"><code class=\"language-c++\"># include &lt; iostream &gt;\n2 # include &lt; vector &gt;\n3 # include &lt; algorithm &gt; // Para sort e greater\n4\n5 using namespace std ;\n6\n7 int main () {\n8 int N , K ;\n9\n10 if ( cin &gt;&gt; N &gt;&gt; K) {\n11 vector &lt;int &gt; notas (N) ;\n12\n13 // Leitura das N notas\n14 for ( int i = 0; i &lt; N; i ++) {\n15 cin &gt;&gt; notas [ i ];\n16 }\n17\n18 // Ordena as notas em ordem decrescente ( maior para menor )\n19 // Usamos greater &lt;int &gt;() para inverter a ordem padrao\n20 sort ( notas . begin () , notas . end () , greater &lt;int &gt;() ) ;\n21\n22 // A nota de corte eh a nota do K- esimo candidato\n23 // Como o vetor comeca em 0 , o K- esimo esta no indice K -1\n24 cout &lt;&lt; notas [K -1] &lt;&lt; endl ;\n25 }\n26 return 0;\n27 }</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>2.4 Complexidade\n• Tempo: O(N log N) devido à ordenação das notas. Como N ≤ 500, isso é extremamente\nrápido.\n• Espaço: O(N) para armazenar o vetor de notas.</p>\n<p>3 Tarefa 3: Bactérias\n3.1 Identificação do Problema\nArquivo: bacterias.cpp\nObjetivo: Calcular quantos dias uma colônia de bactérias pode se reproduzir (multiplicando-se por\num fator P) sem exceder a capacidade N do recipiente.\n3.2 Análise Lógica\nO crescimento é exponencial. Começamos com 1 bactéria no dia 0.\n• Dia 0: 1\n• Dia 1: 1 × P\n• Dia 2: 1 × P × P = P\n2</p>\n<p>• Dia d: P\nd</p>\n<p>Devemos encontrar o maior d tal que:\nP\nd ≤ N</p>\n<p>Podemos simular o processo dia a dia usando um laço de repetição. A cada passo, multiplicamos\na quantidade atual por P. Se o resultado da multiplicação for maior que N, paramos. Caso contrário,\nincrementamos o contador de dias.\nAtenção: O problema pergunta quantos dias podemos deixar se reproduzindo. Se no próximo\ndia exceder a capacidade, não contamos esse dia.\nExemplo Lógico (N = 30, P = 2):\n• Início: 1 bactéria. (Dia 0)\n• Fim do Dia 1: 1 × 2 = 2 (2 ≤ 30, OK). Contamos 1 dia.\n• Fim do Dia 2: 2 × 2 = 4 (4 ≤ 30, OK). Contamos 2 dias.\n• Fim do Dia 3: 4 × 2 = 8 (8 ≤ 30, OK). Contamos 3 dias.\n• Fim do Dia 4: 8 × 2 = 16 (16 ≤ 30, OK). Contamos 4 dias.\n• Tentativa Dia 5: 16 × 2 = 32 (32 > 30, Falha).\n• Resultado: 4 dias.</p>\n<p>3.3 Implementação (C++)</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-c++ line-numbers\"><code class=\"language-c++\"># include &lt; iostream &gt;\n\nusing namespace std ;\n\nint main () {\nint N , P ;\n\n// N: Capacidade , P: Fator de multiplicacao\nif ( cin &gt;&gt; N &gt;&gt; P) {\nint dias = 0;\nint quantidade = 1; // Comeca com 1 bacteria\n\n// Enquanto o proximo estagio de reproducao couber no recipiente\n// Verifica se quantidade * P ainda eh menor ou igual a N\nwhile ( quantidade * P &lt;= N) {\nquantidade = quantidade * P;\ndias ++;\n}\n\ncout &lt;&lt; dias &lt;&lt; endl ;\n}\nreturn 0;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>3.4 Complexidade\n• Tempo: O(logP N). Como estamos multiplicando por P a cada passo, o número de iterações\ncresce logaritmicamente em relação a N. Dado N ≤ 30.000, o loop roda pouquíssimas vezes.\n• Espaço: O(1).</p>"}},"pageContext":{"id":"d03588f5-e898-542a-8eeb-8565368a924b","frontmatter__slug":"resolucao-2024-fase-1","__params":{"frontmatter__slug":"resolucao-2024-fase-1"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}