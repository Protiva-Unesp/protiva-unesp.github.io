{"componentChunkName":"component---src-pages-aprender-09-disjoint-set-union-markdown-remark-frontmatter-slug-tsx","path":"/aprender/09-disjoint-set-union/kmp-string-hashing/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Strings: KMP e String Hashing","description":"descricao","author":"Pedro Henrique Paiola, Rene Pegoraro, Wilson M Yonezawa, Arissa Yoshida, Nicolas Barbosa Gomes, Luis Henrique Morelli"},"html":"<h3>Strings em ProgramaÃ§Ã£o Competitiva</h3>\n<p>â€¢ Existem diversos problemas clÃ¡ssicos associados a Strings. Nesta aula\ntrataremos sobre dois problemas especÃ­ficos:\nâ€¢ Busca em Strings / String matching\nâ€¢ Substrings palindrÃ´micas</p>\n<h3>Busca em strings</h3>\n<p>â€¢ O problema substring search/pattern search/string matching consiste\nem encontrar uma dada string dentro de outra.\nâ€¢ Exemplo:\nS = â€œQue a ForÃ§a esteja com vocÃªâ€\nP = â€œForÃ§aâ€\nâ€¢ O problema substring search ou pattern search consiste em encontrar\numa dada string dentro de outra.\nâ€¢ Exemplo:\nS = â€œQue a <strong>ForÃ§a</strong> esteja com vocÃªâ€\nP = â€œForÃ§aâ€\nOcorrÃªncias: 6 (posiÃ§Ã£o)</p>\n<p>â€¢ O problema substring search ou pattern search consiste em encontrar\numa dada string dentro de outra.\nâ€¢ Exemplo:\nS = â€œ<strong>aaba</strong>acaadaabaabaâ€\nS = â€œaabaacaad<strong>aaba</strong>abaâ€\nS = â€œaabaacaadaab<strong>aaba</strong>â€\nP = â€œaabaâ€\nOcorrÃªncias: 0, 9 e 12</p>\n<h3>Busca em strings</h3>\n<p>â€¢ O problema substring search ou pattern search consiste em encontrar\numa dada string dentro de outra.\nâ€¢ Exemplo:\nS = â€œaabaacaadaab<strong>aaba</strong>â€\nP = â€œaabaâ€\nOcorrÃªncias: 0, 9 e 12\nâ€¢ Algoritmo ingÃªnuo</p>\n<pre><code class=\"language-C++\">int search(string S, string P) {\n    int i, j;\n    for(i = 0; i &#x3C;= S.size() - P.size(); i++) {\n        for(j = 0; j &#x3C; P.size(); j++)\n            if (S[i+j] != P[j])\n                break;\n        if (j == P.size())\n            return i;\n    }\n    return -1;\n}\n</code></pre>\n<p>â€¢ Esse algoritmo, no pior caso, tem complexidade ğ‘‚(ğ‘š. ğ‘›), fazendo ğ‘š. ğ‘›\ncomparaÃ§Ãµes. PorÃ©m, em geral, ele nÃ£o chega a realizar tantas\ncomparaÃ§Ãµes.\nâ€¢ Usar esse algoritmo Ã© bastante razoÃ¡vel para vÃ¡rios casos,\nprincipalmente quando as strings nÃ£o sÃ£o muito grandes.\nâ€¢ Mas, existem algoritmos de busca de substrings mais eficientes, que\npodem ser necessÃ¡rios em algumas situaÃ§Ãµes, como exemplo temos o KMP</p>\n<h3>Alguns conceitos</h3>\n<p>â€¢ Prefixo de uma string S Ã© a string obtida apÃ³s a remoÃ§Ã£o de 0 ou mais\ncaracteres do fim de S.\nâ€¢ â€œaâ€, â€œadcâ€, â€œadcbaaâ€ sÃ£o prefixos de â€œadcbaaâ€\nâ€¢ Sufixo de uma string S Ã© a string obtida apÃ³s a remoÃ§Ã£o de 0 ou mais\ncarateres do inÃ­cio de S.\nâ€¢ â€œaâ€, â€œbaaâ€, â€œadcbaaâ€ sÃ£o sufixos de â€œadcbaaâ€\nâ€¢ Prefixo/sufixo prÃ³prio de S Ã© um prefixo/sufixo de S que Ã© diferente de\nS.\nâ€¢ Substring de uma string S Ã© uma string obtida apÃ³s a remoÃ§Ã£o de 0 ou\nmais caracteres no inÃ­cio ou no fim de S.\nâ€¢ â€œaâ€, â€œcbaâ€, â€œadcâ€, â€œdcbaâ€, â€œadcbaaâ€ sÃ£o substrings de â€œadcbaaâ€</p>\n<h3>KMP</h3>\n<p>â€¢ Knuth Morrit Pratt\nâ€¢ Complexidade: ğ‘‚(ğ‘› + ğ‘š) no pior caso\nâ€¢ No algoritmo ingÃªnuo, sempre que detectamos caracteres diferentes,\navanÃ§Ã¡vamos um caracter na string principal (i++) e testamos toda a\nsubstring, desde o comeÃ§o (comeÃ§ando sempre com j = 0).\nâ€¢ O KMP, porÃ©m, aproveita as comparaÃ§Ãµes que foram feitas antes de\nencontrar dois caracteres diferentes, evitando comparar novamente\ncaracteres que jÃ¡ sabemos que sÃ£o compatÃ­veis.\nâ€¢ A principal ideia deste algoritmo Ã© prÃ©-processar o padrÃ£o P, de modo a\nobter um vetor de inteiros lps, que conta o nÃºmero de caracteres que\npodem ser â€œignoradosâ€ em uma nova comparaÃ§Ã£o.\nâ€¢ O nome lps refere-se Ã  â€œlongest proper prefix and suffixâ€, ou seja, o\nmaior prefixo prÃ³prio (nÃ£o pode ser a prÃ³pria palavra) que tambÃ©m Ã©\nsufixo.\nâ€¢ Conhecido tambÃ©m como funÃ§Ã£o de prefixo.</p>\n<p>img1 - img11\n<img src=\"/static/gif1-20eb39bb98c5b5bdf764f4eca504545d.gif\" alt=\"gif1\"></p>\n<pre><code class=\"language-C++\">int a[MAX], n, m;\nchar S[MAX], P[MAX];\nvoid calculatePrefix(){\n    int i = 0, j = -1;\n    a[0] = -1;\n    while(i &#x3C; m){\n        while(j >= 0 &#x26;&#x26; P[i] != P[j])\n            j = a[j];\n        i++; j++;\n        a[i] = j;\n    }\n}\n\nvector&#x3C;int> KMP2(){ //retorna todas as ocorrÃªncias da substring\n    vector&#x3C;int> resp;\n    int i = 0, j = 0;\n    calculatePrefix();\n    while(i &#x3C; n){\n        while(j >= 0 &#x26;&#x26; S[i] != P[j])\n            j = a[j];\n        i++; j++;\n        if (j == m){\n            resp.push_back(i - m);\n            j = a[j];\n        }\n    }\n    return resp;\n}\n</code></pre>\n<p>â€¢ SugestÃ£o para entender mais sobre o KMP e suas aplicaÃ§Ãµes:\nâ€¢ <a href=\"https://www.youtube.com/watch?v=RXISWaGmYW8\">Algoritmo de KMP | VÃ­deo do Bruno Monteiro</a></p>\n<h3>String Hashing</h3>\n<p>â€¢ Uma tÃ©cnica bastante interessante e relativamente simples de se utilizar\nÃ© a de String Hashing.\nâ€¢ Primeiramente, vamos revisar, de forma muito intuitiva, o conceito de\nHashing.</p>\n<h3>Hashing</h3>\n<p>â€¢ Podemos pensar em uma problema de busca da seguinte forma:\nâ€¢ Considere um conjunto de chaves ğ¾ e um conjunto de valores ğ‘‰, de\nforma que cada chave ğ‘˜ estÃ¡ associada a um Ãºnico valor ğ‘£ (ğ‘šğ‘ğ‘[ğ‘˜] =\nğ‘£).\nâ€¢ Dado um valor ğ‘ qualquer, encontrar a chave ğ‘˜ a qual ele estÃ¡\nassociado (pensando em um vetor, encontrar a posiÃ§Ã£o em que ele se\nencontra)\nâ€¢ O Hashing (tabela de dispersÃ£o) consiste em um mÃ©todo de cÃ¡lculo de\nendereÃ§o (de chave) a partir do valor, de forma que, no caso mÃ©dio, a\nchave pode ser encontrada em tempo constante.\nâ€¢ Exemplo: encontrar a posiÃ§Ã£o em que um certo nome estÃ¡ armazenado.\nâ€¢ Complexidade:\nâ€¢ ğ‘‚(ğ‘›), se o vetor nÃ£o estiver ordenado\nâ€¢ ğ‘‚(log ğ‘›), usando busca binÃ¡ria em vetor ordenado</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/3a8d599ab64bbe795d2ad110b8ce8d95/3f8cf/img12.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 12.269938650306749%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAk0lEQVR42iXK3wrBYACG8V0PmSXNgUtwmxIhIYeK0mz7tlbjQKv5E2bKiRw4MN+zr+3s/T29Wua3+QkThAFulb9TQXqNYkuhI/0WqFZ2U7VaaddQbha/zKkr6xB20N7xiv26SxLOyRKLsxhxdIeQ2nziJSdvDE+bdLcgsvpcgynyYRFtB9yCGbwEF3/CYdPje3fIASYLgI/r7L2LAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img12' title='' src='/static/3a8d599ab64bbe795d2ad110b8ce8d95/a6d36/img12.png' srcset='/static/3a8d599ab64bbe795d2ad110b8ce8d95/222b7/img12.png 163w,\n/static/3a8d599ab64bbe795d2ad110b8ce8d95/ff46a/img12.png 325w,\n/static/3a8d599ab64bbe795d2ad110b8ce8d95/a6d36/img12.png 650w,\n/static/3a8d599ab64bbe795d2ad110b8ce8d95/e548f/img12.png 975w,\n/static/3a8d599ab64bbe795d2ad110b8ce8d95/3f8cf/img12.png 1293w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>â€¢ Agora, suponha que tivÃ©ssemos uma â€œfunÃ§Ã£o mÃ¡gicaâ€ que, dado um\nnome, calcule em tempo constante exatamente a posiÃ§Ã£o que ele\ndeveria ocupar nesse vetor.\nâ€¢ Essa Ã© a ideia da funÃ§Ã£o hash. Claro que na prÃ¡tica isto nÃ£o Ã© tÃ£o\nsimples, mas o nosso foco aqui Ã© mais especÃ­fico.</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/00e05414414a69d5b24a95b394b0c590/d4377/img13.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 12.269938650306749%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkElEQVR42h3J7Q6BYABA4e6yLVsm888NuDyzktD62kqNGHu1lSTNGDqsf+fZkR7umPNU4W6pfH2Nqy5TGj0IhrycAZWpdV0vFApd5WYqtIFGPpOprT6EIy660vkdTZCa7EBiG4jY51MKjqHD1l3SXjMasWMfrKHKKNKIxDH/3+2ceitOkQNNjth4xPacZyH4ARKshugrYJawAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img13' title='' src='/static/00e05414414a69d5b24a95b394b0c590/a6d36/img13.png' srcset='/static/00e05414414a69d5b24a95b394b0c590/222b7/img13.png 163w,\n/static/00e05414414a69d5b24a95b394b0c590/ff46a/img13.png 325w,\n/static/00e05414414a69d5b24a95b394b0c590/a6d36/img13.png 650w,\n/static/00e05414414a69d5b24a95b394b0c590/e548f/img13.png 975w,\n/static/00e05414414a69d5b24a95b394b0c590/d4377/img13.png 1294w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>â€¢ De forma muito simplista, uma funÃ§Ã£o hash nos gera um nÃºmero que\nidentifica um dado qualquer (outro nÃºmero, uma string, uma struct...)\nâ€¢ Idealmente, identifica unicamente, de forma que cada chave estÃ¡\nassociada a apenas um valor. Na prÃ¡tica, podemos ter problema de\ncolisÃµes.\nâ€¢ E o que isto nos ajuda com strings?\nâ€¢ Comparar duas substrings tem complexidade ğ‘‚(ğ‘›), sendo n o nÃºmero\nde caracteres.\nâ€¢ Mas, se calcularmos um hash dessas substrings, obteremos seus\nâ€œnÃºmeros de identificaÃ§Ã£oâ€, que podem ser comparados em ğ‘‚(1).</p>\n<p><img src=\"img14\" alt=\"img14\"></p>\n<p>â€¢ Na prÃ¡tica:\nâ€¢ Dada a(s) string(s) de entrada, realizaremos um prÃ©-processamento\npara o cÃ¡lculo do hash (ğ‘‚(ğ‘›)).\nâ€¢ A partir deste prÃ©-processamento, podemos obter o hash de qualquer\nsubstring em ğ‘‚(1).\nâ€¢ Com isso, a resoluÃ§Ã£o de uma sÃ©rie de problemas terÃ¡ uma grande\nqueda de complexidade, comparada com a soluÃ§Ã£o por forÃ§a bruta.\nâ€¢ Para calcular o hash de uma string qualquer, utilizaremos a tÃ©cnica de\npolynomial rolling. De forma que, dada uma string ğ‘  , o â„ğ‘ğ‘ â„(ğ‘ ) Ã©\ncalculado da seguinte forma:</p>\n<p><img src=\"img15\" alt=\"img15\"></p>\n<p>â€¢ em que ğ‘ƒ Ã© um nÃºmero primo muito grande e ğ‘ uma constante aleatÃ³ria\n(normalmente um primo de valor prÃ³ximo ao tamanho do alfabeto)\nâ€¢ A ideia Ã© evitar colisÃµes, mas nÃ£o entraremos a fundo na fundamentaÃ§Ã£o\nprobabilÃ­stica deste problema.</p>\n<p>â€¢ Exemplo: seja ğ‘  = â€œğ´ğ¿ğ¿ğ¸ğ‘Œâ€, b = 3 e P = 97:</p>\n<p><img src=\"img16\" alt=\"img16\"></p>\n<p>(65 Ã— 3^4 + 76 Ã— 3^3 + 76 Ã— 3^2 + 69 Ã— 3^1 + 89 âˆ— 3^0) ğ‘šğ‘œğ‘‘ 97 = 52\nâ„ğ‘ğ‘ â„(\"ALLEY\") = 52</p>\n<h3>PrÃ©-processamento</h3>\n<p>â€¢ Durante o prÃ©-processamento de nossa substring, construiremos dois\nvetores que serÃ£o importantes para o cÃ¡lculo do hash de qualquer\nsubstring:\nâ€¢ â„[ğ‘–] = armazena o hash do prefixo s[0...i]\nâ€¢ â„[0] = ğ‘ [0]\nâ€¢ â„[ğ‘–] = (â„[ğ‘– âˆ’ 1] âˆ— ğ‘ + ğ‘ [ğ‘–]) ğ‘šğ‘œğ‘‘ ğ‘ƒ\nâ€¢ ğ‘[ğ‘–] = armazena o coeficiente polinomial ğ‘ğ‘– ğ‘šğ‘œğ‘‘ ğ‘ƒ\nâ€¢ ğ‘[0] = 1\nâ€¢ ğ‘[ğ‘–] = (ğ‘[ğ‘– âˆ’ 1] âˆ— ğ‘) ğ‘šğ‘œğ‘‘ ğ‘ƒ</p>\n<p>img17 - img29\n<img src=\"/static/gif2-633011eee0bb7e54f0cdc34b3dd3ac8f.gif\" alt=\"gif2\"></p>\n<p>â€¢ A partir das estruturas criadas no prÃ©-processamento podemos obter o\nhash de qualquer substring em tempo constante.\nâ€¢ Por exemplo, suponha que queremos o hash de â€œLLEâ€ da substring\nanterior, dado por â„ğ‘ğ‘ â„ â€œğ¿ğ¿ğ¸â€ = ğ¿. ğ‘2 + ğ¿. ğ‘ + ğ¸.\nâ€¢ NÃ³s jÃ¡ temos calculados os seguintes hashs:\nâ€¢ â„ 3 = â„ğ‘ğ‘ â„ â€œğ´ğ¿ğ¿ğ¸â€ = ğ´. ğ‘3 + ğ¿. ğ‘2 + ğ¿. ğ‘ + ğ¸\nâ€¢ â„ 0 = â„ğ‘ğ‘ â„ â€œğ´â€ = ğ´\nâ€¢ A partir destes podemos fazer a seguinte operaÃ§Ã£o:\nâ€¢ â„ğ‘ğ‘ â„(\"LLE\") = hash(\"ALLE\") âˆ’ hash(\"A\").ğ‘3\n= ğ´. ğ‘3 + ğ¿. ğ‘2 + ğ¿. ğ‘ + ğ¸ âˆ’ ğ´.ğ‘3</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; '>\n      <a class='gatsby-resp-image-link' href='/static/8a32f22aeaf4390beed4124dc93dc250/2bef9/img30.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.44171779141104%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB0klEQVR42o1SXW/TMBTtL+SZN1555+/wOmASUoGJv8Am2LR2aZnWrel3EuejdZImthvbB9vpoAVVwtKRj+17j499b6fb7cIfP8EOKaWDUtrAcvV77ySaBtrk3i9jXHs/0bFCxYYgWo4QB48gwZPhDwgt5gMEkx9gFXUXaq1xatgze4ETBF9A0m+QpWfQh8yvzfoKDSPGgTTBEv87nKCcv4W+fYHd8A3k4DVE7xXU3Uvo/LsLErxGXdfgXIAz1nLxzJn7miPBKgsg0gnicQ/bcIR0OgRPfChRuyBCCIIgQBzHiKLIzARJkiA0e1EYYrfbHQuy9RwN8bCZ3oCFHujsBtXqFloUrUPBjTuOim2RVxtsWYGaV84lMy61+sthSXyIsI/o4RLlogcyukQ6voLiuQsqigKUUuQFRUYT0GKNvKQoy9Lt22IcCSpeQG0JeB5C7mdBV9ANhy3sc3VtKwnJ0agdlCvUv1Xv2ApqbfpNtVAH9tuEA+yFbXybZ6DkH673bZOuc8yWCfxZhMVqbZ7EkGQl1rQ2T+OOZ7Ry69RwqU73YyfzLxDcf8RieI6Z9wGLwbnjk94ZJv2zlvffYXb33p1PDY8fP5k//nKAC2T+VzN/xi992EYV4pD57AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img30' title='' src='/static/8a32f22aeaf4390beed4124dc93dc250/a6d36/img30.png' srcset='/static/8a32f22aeaf4390beed4124dc93dc250/222b7/img30.png 163w,\n/static/8a32f22aeaf4390beed4124dc93dc250/ff46a/img30.png 325w,\n/static/8a32f22aeaf4390beed4124dc93dc250/a6d36/img30.png 650w,\n/static/8a32f22aeaf4390beed4124dc93dc250/e548f/img30.png 975w,\n/static/8a32f22aeaf4390beed4124dc93dc250/2bef9/img30.png 1024w' sizes='(max-width: 650px) 100vw, 650px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h3>Hash de substring</h3>\n<p>â€¢ A partir das estruturas criadas no prÃ©-processamento podemos obter o\nhash de qualquer substring em tempo constante.\nâ€¢ Generalizando:\nâ„ğ‘ğ‘ â„ ğ‘† [ğ‘™ â€¦ ğ‘Ÿ] = (â„ [ğ‘Ÿ] âˆ’ â„ [ğ‘™ âˆ’ 1] âˆ— ğ‘ [ğ‘Ÿ âˆ’ ğ‘™ + 1] ) ğ‘šğ‘œğ‘‘ ğ‘ƒ</p>\n<p>#Complexidade do String Hashing\nâ€¢ PrÃ©-processamento: ğ‘‚(ğ‘›)\nâ€¢ Consulta: ğ‘‚(1)</p>\n<h3>ImplementaÃ§Ã£o</h3>\n<pre><code class=\"language-C++\">mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());\nconst ll P = 1e18+9;\nconst ll b = uniform_int_distribution&#x3C;ll>(0, P-1)(rng);\ninline ll mult(ll a, ll b, ll mod){\n    return (a*b-(ll)((long double)a/mod*b)*mod + mod)%mod;\n}\n\nstruct hash_str\n{\n    vector&#x3C;ll> h, p;\n    hash_str(string s) : h(s.size()), p(s.size()) {\n        int n = s.size();\n        h[0] = s[0] + 128;\n        p[0] = 1;\n        for(int i = 1; i &#x3C; n; i++){\n            h[i] = (mult(h[i-1],b,P) + s[i] + 128) % P;\n            p[i] = mult(p[i-1],b,P);\n        }\n    }\n\n    ll sub_hash(int l, int r){\n        if (l == 0)\n            return h[r];\n        ll ans = (h[r] - mult(h[l-1], p[r-l+1],P)) % P;\n        if (ans &#x3C; 0)\n            ans += P;\n        return ans;\n    }\n};\n</code></pre>\n<h3>Busca em strings com String Hashing</h3>\n<p>â€¢ Dada uma string ğ‘†, de tamanho ğ‘›, como determinados se a string ğ‘ƒ, de\ntamanho ğ‘š, estÃ¡ presente em ğ‘†?\nâ€¢ Calculamos o hash das duas strings, e entÃ£o comparamos ğ‘ƒ com todas as\nsubstrings de tamanho ğ‘š de ğ‘†. A ideia Ã© semelhante a forÃ§a bruta,\nporÃ©m se torna eficiente devido ao uso do hashing.\nâ€¢ Algoritmo de Rabin-Karp</p>\n<pre><code class=\"language-C++\">hash_str hs(s), hp(p);\nint ans = 0;\nvector&#x3C;int> pos;\nint n = s.size(), m = p.size();\nfor(int i = 0; i &#x3C;= n-m; i++){\n    if (hs.sub_hash(i, i+m-1) == hp.sub_hash(0, m-1))\n    {\n        ans++;\n        pos.push_back(i);\n    }\n}\n</code></pre>\n<p>â€¢ Complexidades:\nâ€¢ ForÃ§a bruta: ğ‘‚(ğ‘›. ğ‘š)\nâ€¢ KMP: ğ‘‚(ğ‘› + ğ‘š)\nâ€¢ String Hashing:\nâ€¢ PrÃ©-processamento: ğ‘‚(ğ‘› + ğ‘š)\nâ€¢ Consulta: ğ‘‚(ğ‘› âˆ’ ğ‘š)</p>\n<h3>Exemplos de outros problemas</h3>\n<p>â€¢ Determinar a maior substring de ğ‘ƒ que ocorre em ğ‘†\nâ€¢ Busca binÃ¡ria no tamanho da substring. Procura todas as substrings de tamanho ğ‘¥ de ğ‘ƒ em ğ‘†.\nâ€¢ ğ‘‚(ğ‘›Â²log ğ‘›)\nâ€¢ Determinar a quantidade de diferentes substrings de S.\nâ€¢ Para cada possÃ­vel tamanho de substring cria um set e o povoe com o hash de todas\nas substrings possÃ­veis. Somando o tamanho dos sets teremos a quantidade de\ndiferentes substrings de ğ‘†.\nâ€¢ ğ‘‚(ğ‘›Â²log ğ‘›)\nâ€¢ Determinar a maior substring palindrÃ´mica de S.\nâ€¢ Backward hash: calcular o hash para a string invertida tambÃ©m.\nâ€¢ ğ‘‚(ğ‘›Â²)\nâ€¢ Utilizando algoritmo de Manacher (sem String Hashing): ğ‘‚(ğ‘›)</p>\n<p>Cuidados\nâ€¢ O maior problema da tÃ©cnica de String Hashing Ã© a possibilidade da\nocorrÃªncia de colisÃµes: quando duas strings diferentes resultam no\nmesmo hash.\nâ€¢ Formas de diminuir a probabilidade de ocorrÃªncia:\nâ€¢ UtilizaÃ§Ã£o de valores adequados para os parÃ¢metros ğ‘ e ğ‘ƒ.\nâ€¢ Duplo hashing.</p>\n<p>Outras tÃ©cnicas para lidar com Strings\nâ€¢ Existem diversas outras tÃ©cnicas e estruturas que ajudam a lidar com\nproblemas de Strings, por exemplo:\nâ€¢ Para lidar com palÃ­ndromos:\nâ€¢ Algoritmo de Manacher\nâ€¢ Palindromic Tree\nâ€¢ Z-function\nâ€¢ String matching utilizando autÃ´mato finito\nâ€¢ Algoritmo de Aho-Corasick\nâ€¢ Trie\nâ€¢ Suffix Array\nâ€¢ Suffix Tree\nâ€¢ AutÃ´mato de Sufixos\nâ€¢ FatorizaÃ§Ã£o de Lyndon / Algoritmo de Duval</p>\n<h3>ReferÃªncias</h3>\n<p>S. Halim e F. Halim. Competitive Programming 2.\nFÃ¡bio L. Usberti. Processamento de Cadeias de Caracteres. Summer School 2019.\nRafael Grandsire. String Hashing. Summer School 2022.\n<a href=\"https://www.youtube.com/watch?v=RXISWaGmYW8\">https://www.youtube.com/watch?v=RXISWaGmYW8</a>\n<a href=\"https://cp-algorithms-brasil.com/strings/prefixo.html\">https://cp-algorithms-brasil.com/strings/prefixo.html</a>\n<a href=\"https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/\">https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/</a>\n<a href=\"https://www.ime.usp.br/~pf/estruturas-de-dados/aulas/kmp.html\">https://www.ime.usp.br/~pf/estruturas-de-dados/aulas/kmp.html</a>\n<a href=\"http://www2.ic.uff.br/~boeres/slides_ed/ed_TabelaHash.pdf\">http://www2.ic.uff.br/~boeres/slides_ed/ed_TabelaHash.pdf</a>\n<a href=\"https://usaco.guide/CPH.pdf\">https://usaco.guide/CPH.pdf</a>\n<a href=\"https://cp-algorithms.com/string/string-hashing.html\">https://cp-algorithms.com/string/string-hashing.html</a>\n<a href=\"https://www.geeksforgeeks.org/string-hashing-using-polynomial-rolling-hash-function/\">https://www.geeksforgeeks.org/string-hashing-using-polynomial-rolling-hash-function/</a>\n<a href=\"https://usaco.guide/gold/string-hashing?lang=cpp\">https://usaco.guide/gold/string-hashing?lang=cpp</a></p>"}},"pageContext":{"id":"d60d1498-6169-5413-8a8d-f2f857f8f829","frontmatter__slug":"kmp-string-hashing","__params":{"frontmatter__slug":"kmp-string-hashing"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}