{"componentChunkName":"component---src-pages-aprender-13-kmp-string-hashing-markdown-remark-frontmatter-slug-tsx","path":"/aprender/13-kmp-string-hashing/complexidade-algoritmos/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Complexidade de Algoritmos","description":"descricao","author":"Pedro Henrique Paiola, Rene Pegoraro, Wilson M. Yonezawa"},"html":"<h3>Introdução</h3>\n<p>● O que é um algoritmo?\n● Objetivo: Encontrar e/ou projetar algoritmos\neficientes para problemas computacionais\n● Como projetar e avaliar um algoritmo?\n“Informalmente, um algoritmo é qualquer procedimento computacional bem\ndefinido que recebe algum valor, ou conjunto de valores, como entrada e\nproduz algum valor, ou conjunto de valores, como saída.\nUm algoritmo é, portanto, uma sequência de passos computacionais que\ntransformam a entrada na saída”. Tradução livre do livro “Introduction to\nAlgorithms do Cormen, Leiserson, Rivest e Stein, 2009.</p>\n<p>Algoritmo (exemplo de representação)\nmdc(a, b)</p>\n<ul>\n<li>Etapa 1: Dados dos números inteiros a e b</li>\n<li>Etapa 2: R é o resto da divisão de a por b</li>\n<li>Etapa 3: Faça a = b e b = R</li>\n<li>Etapa 4: Repita as etapas 2 e 3 enquanto o</li>\n<li>resto de a dividido por b for maior que zero</li>\n<li>Etapa 5: mdc = b</li>\n<li>Etapa 6: Fim</li>\n</ul>\n<h2>Eficiência de um algoritmo</h2>\n<p>● Tempo (de execução) e espaço (memória)\n● Tempo de execução pode variar dependendo do computador\n● Comportamento do algoritmo em função do tamanho da entrada de dados (n</p>\n<h2>Exemplos de problemas</h2>\n<p>● Encontrar o maior elemento de uma lista de tamanho N\n● Mostrar todos os pares ordenados de uma lista de tamanho N\n● Ordenar uma lista com N números inteiros\n● Encontrar um elemento em uma lista ordenada de tamanho N\n● Permutar as letras de uma string de tamanho N\n● 3-SAT, problema do caixeiro viajante, etc</p>\n<h2>Big O</h2>\n<p>A notação Big O descreve a complexidade de uma\nfunção/algoritmo, seja seu tempo de execução (a quantidade de\ntempo que um algoritmo leva para completar sua tarefa) ou a\ncomplexidade do espaço (a quantidade de espaço que um\nalgoritmo usa). É usado para ver quanto mais trabalho precisa ser\nfeito por um algoritmo quando a entrada aumenta</p>\n<table>\n<thead>\n<tr>\n<th>Complexidade do algoritmo</th>\n<th>Terminologia</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>O(1)</td>\n<td>Complexidade constante</td>\n</tr>\n<tr>\n<td>O(log n)</td>\n<td>Complexidade logarítmica</td>\n</tr>\n<tr>\n<td>O(n)</td>\n<td>Complexidade linear</td>\n</tr>\n<tr>\n<td>O(n log n)</td>\n<td>Complexidade n log n</td>\n</tr>\n<tr>\n<td>O(n^b)</td>\n<td>Complexidade polinomial</td>\n</tr>\n<tr>\n<td>O(b^n ), b > 1</td>\n<td>Complexidade exponencial</td>\n</tr>\n<tr>\n<td>O(n!)</td>\n<td>Complexidade fatorial</td>\n</tr>\n</tbody>\n</table>\n<h3>Voltando aos Exemplos</h3>\n<p>● O(n) - Encontrar o maior elemento de uma lista de tamanho N\n● O(n^2) - Mostrar todos os pares ordenados de uma lista de tamanho N\n● O (log n) - Encontrar um elemento em uma lista ordenada de tamanho N\n● O(n log n) - Ordenar uma lista com N números inteiros\n● O(k^n) - 3-SAT, problema do caixeiro viajante, etc\n● O(n!) - Permutar as letras de uma string de tamanho N</p>\n<h3>Voltando aos Algoritmos</h3>\n<p>mdc(a, b)\nEtapa 1: Dados dos números inteiros a e b\nEtapa 2: R é o resto da divisão de a por b\nEtapa 3: Faça a = b e b = R\nEtapa 4: Repita as etapas 2 e 3 enquanto o\nresto de a dividido por b for maior que zero\nEtapa 5: mdc = b\nEtapa 6: Fim</p>\n<pre><code class=\"language-C++\">int mdc(int a,int b) {\n    int R;\n    while ((a % b) > 0) {\n        R = a % b;\n        a = b;\n        b = R;\n    }\n    return b;\n}\n</code></pre>\n<h3>Considerações finais</h3>\n<ul>\n<li>\n<p>Observar o problema e o tamanho da entrada (N)</p>\n</li>\n<li>\n<p>Procurar e/ou buscar projetar algoritmos com complexidade:</p>\n</li>\n</ul>\n<p>logarítmica O(log N), linear O(n), linear/logarítmica O(n log n),\npolinomial O(n k ).</p>\n<ul>\n<li>Se a complexidade do problema é do tipo exponencial ou fatorial,</li>\n</ul>\n<p>verificar se é possível reduzir para polinomial.\nProblemas recursivos devem ser analisados com cuidado visto que,\ngeralmente, aumentam a complexidade do algoritmo.</p>"}},"pageContext":{"id":"bb226f00-e0bb-59e7-87eb-8b0e10c63e8b","frontmatter__slug":"complexidade-algoritmos","__params":{"frontmatter__slug":"complexidade-algoritmos"}}},"staticQueryHashes":["3159585216"],"slicesMap":{}}